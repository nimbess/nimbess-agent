// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

package bess_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BESSControl service

type BESSControlClient interface {
	// / Query version of bessd
	GetVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	// / Reset the current packet processing datapath to the initial state.
	// /
	// / This command is identical to the following sequence:
	// /   ResetModules()
	// /   ResetPorts()
	// /   ResetTcs()
	// /   ResetWorkers()
	// / As it clears everything, BESS should appear as if the daemon has freshly
	// / started (if not, it is a bug; please report).
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Terminate the BESS daemon.
	// /
	// / BESS daemon shuts off in a graceful manner. Note that this command is
	// / "asynchronous": this command doesn't block until the BESS daemon has
	// / shut off.
	// /
	// / NOTE: There should be no running worker to run this command.
	// / FIXME: rename (e.g., Terminate)
	KillBess(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Import a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ImportPlugin(ctx context.Context, in *ImportPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Unload a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	UnloadPlugin(ctx context.Context, in *UnloadPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / List imported plugins
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ListPlugins(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
	// / Pause all running workers temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseALl at the beginning and ResumeAll at the end.
	// /  PauseAll()
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeAll()
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Pause the specified worker temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
	// /  PauseWorker(0)
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeWorker(0)
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseWorker(ctx context.Context, in *PauseWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Resume the specified worker
	ResumeWorker(ctx context.Context, in *ResumeWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Resume all paused workers
	ResumeAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Remove all existing workers
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error)
	// / Create a new worker
	// /
	// / NOTE: There should be no running worker to run this command.
	AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Remove a single worker
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyWorker(ctx context.Context, in *DestroyWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Remove all existing traffic classes
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetTcs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListTcs(ctx context.Context, in *ListTcsRequest, opts ...grpc.CallOption) (*ListTcsResponse, error)
	// / Check scheduling contraints
	CheckSchedulingConstraints(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*CheckSchedulingConstraintsResponse, error)
	// / Create a new traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	AddTc(ctx context.Context, in *AddTcRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Update parameters of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParams(ctx context.Context, in *UpdateTcParamsRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Change parent (and child arguments) of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParent(ctx context.Context, in *UpdateTcParentRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Collect statistics of a traffic class
	GetTcStats(ctx context.Context, in *GetTcStatsRequest, opts ...grpc.CallOption) (*GetTcStatsResponse, error)
	// / Enumerate all port drivers available
	ListDrivers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListDriversResponse, error)
	// / Query detailed information of a port driver
	GetDriverInfo(ctx context.Context, in *GetDriverInfoRequest, opts ...grpc.CallOption) (*GetDriverInfoResponse, error)
	// / Remove all initialized ports
	// /
	// / Will fail if there are modules that are still using ports.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all initialized ports
	ListPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPortsResponse, error)
	// / Create a new port from the specified driver
	CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*CreatePortResponse, error)
	// / Remove a port
	// /
	// / The port should not be being used by a port-related module.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	DestroyPort(ctx context.Context, in *DestroyPortRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Runtime-updatable configuration
	SetPortConf(ctx context.Context, in *SetPortConfRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	GetPortConf(ctx context.Context, in *GetPortConfRequest, opts ...grpc.CallOption) (*GetPortConfResponse, error)
	// / Collect port statistics
	// /
	// / At the moment, per-queue stats are not supported.
	GetPortStats(ctx context.Context, in *GetPortStatsRequest, opts ...grpc.CallOption) (*GetPortStatsResponse, error)
	// / Query link status
	GetLinkStatus(ctx context.Context, in *GetLinkStatusRequest, opts ...grpc.CallOption) (*GetLinkStatusResponse, error)
	// / Enumerate all module types available
	ListMclass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListMclassResponse, error)
	// / Query detailed information of a module type
	GetMclassInfo(ctx context.Context, in *GetMclassInfoRequest, opts ...grpc.CallOption) (*GetMclassInfoResponse, error)
	// / Remove all modules.
	// /
	// / This RPC will always succeed (unless there is a running worker)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all initialized modules
	ListModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListModulesResponse, error)
	// / Create a new module instance from the given module type
	// /
	// / NOTE: There should be no running worker to run this command.
	CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*CreateModuleResponse, error)
	// / Destroy an exsting module
	// /
	// / If the module is connected to other modules' input/output gate, they are
	// / disconnected first. All tasks created by the module will also be destoyed.
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyModule(ctx context.Context, in *DestroyModuleRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Fetch detailed information of an module instance
	GetModuleInfo(ctx context.Context, in *GetModuleInfoRequest, opts ...grpc.CallOption) (*GetModuleInfoResponse, error)
	// / Connect two modules.
	// /
	// / Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
	// / will be fed to m2's igate). The oate can be connected to only one igate,
	// / while the igate can be connected to multiple output gates.
	// /
	// / NOTE: There should be no running worker to run this command.
	ConnectModules(ctx context.Context, in *ConnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Disconnect two modules.
	// /
	// / It removes a connection between two modules (you specify the previous one
	// / and its output gate). All packets coming out from the ogate will be
	// / dropped. Once disconnected, the ogate can be connected
	// / to any input gate.
	// /
	// / NOTE: There should be no running worker to run this command.
	DisconnectModules(ctx context.Context, in *DisconnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Dump various stats about BESS's packet pools
	DumpMempool(ctx context.Context, in *DumpMempoolRequest, opts ...grpc.CallOption) (*DumpMempoolResponse, error)
	// / Send a command to the specified module instance.
	// /
	// / Each module type defines a list of modyle-specific commands, which
	// / allow external programs to communicate with the module at runtime.
	// / See module_msg.proto for details.
	// /
	// / NOTE: Some commands cannot be used if there are running workers.
	// /       For those commands you must pause all workers first.
	ModuleCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	// / Enumerate all gatehook types available
	ListGateHookClass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHookClassResponse, error)
	// / Query detailed information of a gatehook type
	GetGateHookClassInfo(ctx context.Context, in *GetGateHookClassInfoRequest, opts ...grpc.CallOption) (*GetGateHookClassInfoResponse, error)
	// / Enable/Disable a gate hook.
	ConfigureGateHook(ctx context.Context, in *ConfigureGateHookRequest, opts ...grpc.CallOption) (*ConfigureGateHookResponse, error)
	// / Enumerate all gatehook installed
	ListGateHooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHooksResponse, error)
	// / Send command to gate hook instance.
	GateHookCommand(ctx context.Context, in *GateHookCommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	// / Enable/Disable a resume hook.
	ConfigureResumeHook(ctx context.Context, in *ConfigureResumeHookRequest, opts ...grpc.CallOption) (*CommandResponse, error)
}

type bESSControlClient struct {
	cc *grpc.ClientConn
}

func NewBESSControlClient(cc *grpc.ClientConn) BESSControlClient {
	return &bESSControlClient{cc}
}

func (c *bESSControlClient) GetVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ResetAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) KillBess(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/KillBess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ImportPlugin(ctx context.Context, in *ImportPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ImportPlugin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UnloadPlugin(ctx context.Context, in *UnloadPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/UnloadPlugin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListPlugins(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	out := new(ListPluginsResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListPlugins", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) PauseAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/PauseAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) PauseWorker(ctx context.Context, in *PauseWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/PauseWorker", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResumeWorker(ctx context.Context, in *ResumeWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ResumeWorker", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResumeAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ResumeAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ResetWorkers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error) {
	out := new(ListWorkersResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListWorkers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/AddWorker", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyWorker(ctx context.Context, in *DestroyWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/DestroyWorker", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetTcs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ResetTcs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListTcs(ctx context.Context, in *ListTcsRequest, opts ...grpc.CallOption) (*ListTcsResponse, error) {
	out := new(ListTcsResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListTcs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CheckSchedulingConstraints(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*CheckSchedulingConstraintsResponse, error) {
	out := new(CheckSchedulingConstraintsResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/CheckSchedulingConstraints", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) AddTc(ctx context.Context, in *AddTcRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/AddTc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UpdateTcParams(ctx context.Context, in *UpdateTcParamsRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/UpdateTcParams", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UpdateTcParent(ctx context.Context, in *UpdateTcParentRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/UpdateTcParent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetTcStats(ctx context.Context, in *GetTcStatsRequest, opts ...grpc.CallOption) (*GetTcStatsResponse, error) {
	out := new(GetTcStatsResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetTcStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListDrivers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListDriversResponse, error) {
	out := new(ListDriversResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListDrivers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetDriverInfo(ctx context.Context, in *GetDriverInfoRequest, opts ...grpc.CallOption) (*GetDriverInfoResponse, error) {
	out := new(GetDriverInfoResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetDriverInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ResetPorts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPortsResponse, error) {
	out := new(ListPortsResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListPorts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*CreatePortResponse, error) {
	out := new(CreatePortResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/CreatePort", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyPort(ctx context.Context, in *DestroyPortRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/DestroyPort", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) SetPortConf(ctx context.Context, in *SetPortConfRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/SetPortConf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetPortConf(ctx context.Context, in *GetPortConfRequest, opts ...grpc.CallOption) (*GetPortConfResponse, error) {
	out := new(GetPortConfResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetPortConf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetPortStats(ctx context.Context, in *GetPortStatsRequest, opts ...grpc.CallOption) (*GetPortStatsResponse, error) {
	out := new(GetPortStatsResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetPortStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetLinkStatus(ctx context.Context, in *GetLinkStatusRequest, opts ...grpc.CallOption) (*GetLinkStatusResponse, error) {
	out := new(GetLinkStatusResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetLinkStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListMclass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListMclassResponse, error) {
	out := new(ListMclassResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListMclass", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetMclassInfo(ctx context.Context, in *GetMclassInfoRequest, opts ...grpc.CallOption) (*GetMclassInfoResponse, error) {
	out := new(GetMclassInfoResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetMclassInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ResetModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListModulesResponse, error) {
	out := new(ListModulesResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*CreateModuleResponse, error) {
	out := new(CreateModuleResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/CreateModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyModule(ctx context.Context, in *DestroyModuleRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/DestroyModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetModuleInfo(ctx context.Context, in *GetModuleInfoRequest, opts ...grpc.CallOption) (*GetModuleInfoResponse, error) {
	out := new(GetModuleInfoResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetModuleInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConnectModules(ctx context.Context, in *ConnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ConnectModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DisconnectModules(ctx context.Context, in *DisconnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/DisconnectModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DumpMempool(ctx context.Context, in *DumpMempoolRequest, opts ...grpc.CallOption) (*DumpMempoolResponse, error) {
	out := new(DumpMempoolResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/DumpMempool", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ModuleCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ModuleCommand", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListGateHookClass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHookClassResponse, error) {
	out := new(ListGateHookClassResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListGateHookClass", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetGateHookClassInfo(ctx context.Context, in *GetGateHookClassInfoRequest, opts ...grpc.CallOption) (*GetGateHookClassInfoResponse, error) {
	out := new(GetGateHookClassInfoResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GetGateHookClassInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConfigureGateHook(ctx context.Context, in *ConfigureGateHookRequest, opts ...grpc.CallOption) (*ConfigureGateHookResponse, error) {
	out := new(ConfigureGateHookResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ConfigureGateHook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListGateHooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHooksResponse, error) {
	out := new(ListGateHooksResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ListGateHooks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GateHookCommand(ctx context.Context, in *GateHookCommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/GateHookCommand", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConfigureResumeHook(ctx context.Context, in *ConfigureResumeHookRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := grpc.Invoke(ctx, "/bess.pb.BESSControl/ConfigureResumeHook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BESSControl service

type BESSControlServer interface {
	// / Query version of bessd
	GetVersion(context.Context, *EmptyRequest) (*VersionResponse, error)
	// / Reset the current packet processing datapath to the initial state.
	// /
	// / This command is identical to the following sequence:
	// /   ResetModules()
	// /   ResetPorts()
	// /   ResetTcs()
	// /   ResetWorkers()
	// / As it clears everything, BESS should appear as if the daemon has freshly
	// / started (if not, it is a bug; please report).
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Terminate the BESS daemon.
	// /
	// / BESS daemon shuts off in a graceful manner. Note that this command is
	// / "asynchronous": this command doesn't block until the BESS daemon has
	// / shut off.
	// /
	// / NOTE: There should be no running worker to run this command.
	// / FIXME: rename (e.g., Terminate)
	KillBess(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Import a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ImportPlugin(context.Context, *ImportPluginRequest) (*EmptyResponse, error)
	// / Unload a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	UnloadPlugin(context.Context, *UnloadPluginRequest) (*EmptyResponse, error)
	// / List imported plugins
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ListPlugins(context.Context, *EmptyRequest) (*ListPluginsResponse, error)
	// / Pause all running workers temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseALl at the beginning and ResumeAll at the end.
	// /  PauseAll()
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeAll()
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Pause the specified worker temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
	// /  PauseWorker(0)
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeWorker(0)
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseWorker(context.Context, *PauseWorkerRequest) (*EmptyResponse, error)
	// / Resume the specified worker
	ResumeWorker(context.Context, *ResumeWorkerRequest) (*EmptyResponse, error)
	// / Resume all paused workers
	ResumeAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Remove all existing workers
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetWorkers(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListWorkers(context.Context, *EmptyRequest) (*ListWorkersResponse, error)
	// / Create a new worker
	// /
	// / NOTE: There should be no running worker to run this command.
	AddWorker(context.Context, *AddWorkerRequest) (*EmptyResponse, error)
	// / Remove a single worker
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyWorker(context.Context, *DestroyWorkerRequest) (*EmptyResponse, error)
	// / Remove all existing traffic classes
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetTcs(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListTcs(context.Context, *ListTcsRequest) (*ListTcsResponse, error)
	// / Check scheduling contraints
	CheckSchedulingConstraints(context.Context, *EmptyRequest) (*CheckSchedulingConstraintsResponse, error)
	// / Create a new traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	AddTc(context.Context, *AddTcRequest) (*EmptyResponse, error)
	// / Update parameters of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParams(context.Context, *UpdateTcParamsRequest) (*EmptyResponse, error)
	// / Change parent (and child arguments) of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParent(context.Context, *UpdateTcParentRequest) (*EmptyResponse, error)
	// / Collect statistics of a traffic class
	GetTcStats(context.Context, *GetTcStatsRequest) (*GetTcStatsResponse, error)
	// / Enumerate all port drivers available
	ListDrivers(context.Context, *EmptyRequest) (*ListDriversResponse, error)
	// / Query detailed information of a port driver
	GetDriverInfo(context.Context, *GetDriverInfoRequest) (*GetDriverInfoResponse, error)
	// / Remove all initialized ports
	// /
	// / Will fail if there are modules that are still using ports.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetPorts(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all initialized ports
	ListPorts(context.Context, *EmptyRequest) (*ListPortsResponse, error)
	// / Create a new port from the specified driver
	CreatePort(context.Context, *CreatePortRequest) (*CreatePortResponse, error)
	// / Remove a port
	// /
	// / The port should not be being used by a port-related module.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	DestroyPort(context.Context, *DestroyPortRequest) (*EmptyResponse, error)
	// / Runtime-updatable configuration
	SetPortConf(context.Context, *SetPortConfRequest) (*EmptyResponse, error)
	GetPortConf(context.Context, *GetPortConfRequest) (*GetPortConfResponse, error)
	// / Collect port statistics
	// /
	// / At the moment, per-queue stats are not supported.
	GetPortStats(context.Context, *GetPortStatsRequest) (*GetPortStatsResponse, error)
	// / Query link status
	GetLinkStatus(context.Context, *GetLinkStatusRequest) (*GetLinkStatusResponse, error)
	// / Enumerate all module types available
	ListMclass(context.Context, *EmptyRequest) (*ListMclassResponse, error)
	// / Query detailed information of a module type
	GetMclassInfo(context.Context, *GetMclassInfoRequest) (*GetMclassInfoResponse, error)
	// / Remove all modules.
	// /
	// / This RPC will always succeed (unless there is a running worker)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetModules(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all initialized modules
	ListModules(context.Context, *EmptyRequest) (*ListModulesResponse, error)
	// / Create a new module instance from the given module type
	// /
	// / NOTE: There should be no running worker to run this command.
	CreateModule(context.Context, *CreateModuleRequest) (*CreateModuleResponse, error)
	// / Destroy an exsting module
	// /
	// / If the module is connected to other modules' input/output gate, they are
	// / disconnected first. All tasks created by the module will also be destoyed.
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyModule(context.Context, *DestroyModuleRequest) (*EmptyResponse, error)
	// / Fetch detailed information of an module instance
	GetModuleInfo(context.Context, *GetModuleInfoRequest) (*GetModuleInfoResponse, error)
	// / Connect two modules.
	// /
	// / Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
	// / will be fed to m2's igate). The oate can be connected to only one igate,
	// / while the igate can be connected to multiple output gates.
	// /
	// / NOTE: There should be no running worker to run this command.
	ConnectModules(context.Context, *ConnectModulesRequest) (*EmptyResponse, error)
	// / Disconnect two modules.
	// /
	// / It removes a connection between two modules (you specify the previous one
	// / and its output gate). All packets coming out from the ogate will be
	// / dropped. Once disconnected, the ogate can be connected
	// / to any input gate.
	// /
	// / NOTE: There should be no running worker to run this command.
	DisconnectModules(context.Context, *DisconnectModulesRequest) (*EmptyResponse, error)
	// / Dump various stats about BESS's packet pools
	DumpMempool(context.Context, *DumpMempoolRequest) (*DumpMempoolResponse, error)
	// / Send a command to the specified module instance.
	// /
	// / Each module type defines a list of modyle-specific commands, which
	// / allow external programs to communicate with the module at runtime.
	// / See module_msg.proto for details.
	// /
	// / NOTE: Some commands cannot be used if there are running workers.
	// /       For those commands you must pause all workers first.
	ModuleCommand(context.Context, *CommandRequest) (*CommandResponse, error)
	// / Enumerate all gatehook types available
	ListGateHookClass(context.Context, *EmptyRequest) (*ListGateHookClassResponse, error)
	// / Query detailed information of a gatehook type
	GetGateHookClassInfo(context.Context, *GetGateHookClassInfoRequest) (*GetGateHookClassInfoResponse, error)
	// / Enable/Disable a gate hook.
	ConfigureGateHook(context.Context, *ConfigureGateHookRequest) (*ConfigureGateHookResponse, error)
	// / Enumerate all gatehook installed
	ListGateHooks(context.Context, *EmptyRequest) (*ListGateHooksResponse, error)
	// / Send command to gate hook instance.
	GateHookCommand(context.Context, *GateHookCommandRequest) (*CommandResponse, error)
	// / Enable/Disable a resume hook.
	ConfigureResumeHook(context.Context, *ConfigureResumeHookRequest) (*CommandResponse, error)
}

func RegisterBESSControlServer(s *grpc.Server, srv BESSControlServer) {
	s.RegisterService(&_BESSControl_serviceDesc, srv)
}

func _BESSControl_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetVersion(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_KillBess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).KillBess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/KillBess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).KillBess(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ImportPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ImportPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ImportPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ImportPlugin(ctx, req.(*ImportPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UnloadPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnloadPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UnloadPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/UnloadPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UnloadPlugin(ctx, req.(*UnloadPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListPlugins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListPlugins(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_PauseAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).PauseAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/PauseAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).PauseAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_PauseWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).PauseWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/PauseWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).PauseWorker(ctx, req.(*PauseWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResumeWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResumeWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResumeWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResumeWorker(ctx, req.(*ResumeWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResumeAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResumeAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResumeAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResumeAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetWorkers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetWorkers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListWorkers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListWorkers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_AddWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).AddWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/AddWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).AddWorker(ctx, req.(*AddWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DestroyWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyWorker(ctx, req.(*DestroyWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetTcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetTcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetTcs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetTcs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListTcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListTcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListTcs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListTcs(ctx, req.(*ListTcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CheckSchedulingConstraints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CheckSchedulingConstraints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/CheckSchedulingConstraints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CheckSchedulingConstraints(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_AddTc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).AddTc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/AddTc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).AddTc(ctx, req.(*AddTcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UpdateTcParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTcParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UpdateTcParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/UpdateTcParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UpdateTcParams(ctx, req.(*UpdateTcParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UpdateTcParent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTcParentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UpdateTcParent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/UpdateTcParent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UpdateTcParent(ctx, req.(*UpdateTcParentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetTcStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTcStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetTcStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetTcStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetTcStats(ctx, req.(*GetTcStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListDrivers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListDrivers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetDriverInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriverInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetDriverInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetDriverInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetDriverInfo(ctx, req.(*GetDriverInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetPorts(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListPorts(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CreatePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CreatePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/CreatePort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CreatePort(ctx, req.(*CreatePortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DestroyPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyPort(ctx, req.(*DestroyPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_SetPortConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPortConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).SetPortConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/SetPortConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).SetPortConf(ctx, req.(*SetPortConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetPortConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetPortConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetPortConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetPortConf(ctx, req.(*GetPortConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetPortStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetPortStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetPortStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetPortStats(ctx, req.(*GetPortStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetLinkStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinkStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetLinkStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetLinkStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetLinkStatus(ctx, req.(*GetLinkStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListMclass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListMclass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListMclass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListMclass(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetMclassInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMclassInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetMclassInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetMclassInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetMclassInfo(ctx, req.(*GetMclassInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetModules(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListModules(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CreateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CreateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/CreateModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CreateModule(ctx, req.(*CreateModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DestroyModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyModule(ctx, req.(*DestroyModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetModuleInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModuleInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetModuleInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetModuleInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetModuleInfo(ctx, req.(*GetModuleInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConnectModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConnectModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ConnectModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConnectModules(ctx, req.(*ConnectModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DisconnectModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DisconnectModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DisconnectModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DisconnectModules(ctx, req.(*DisconnectModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DumpMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpMempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DumpMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DumpMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DumpMempool(ctx, req.(*DumpMempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ModuleCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ModuleCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ModuleCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ModuleCommand(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListGateHookClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListGateHookClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListGateHookClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListGateHookClass(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetGateHookClassInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGateHookClassInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetGateHookClassInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetGateHookClassInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetGateHookClassInfo(ctx, req.(*GetGateHookClassInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConfigureGateHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureGateHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConfigureGateHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ConfigureGateHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConfigureGateHook(ctx, req.(*ConfigureGateHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListGateHooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListGateHooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListGateHooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListGateHooks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GateHookCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateHookCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GateHookCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GateHookCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GateHookCommand(ctx, req.(*GateHookCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConfigureResumeHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureResumeHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConfigureResumeHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ConfigureResumeHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConfigureResumeHook(ctx, req.(*ConfigureResumeHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BESSControl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bess.pb.BESSControl",
	HandlerType: (*BESSControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _BESSControl_GetVersion_Handler,
		},
		{
			MethodName: "ResetAll",
			Handler:    _BESSControl_ResetAll_Handler,
		},
		{
			MethodName: "KillBess",
			Handler:    _BESSControl_KillBess_Handler,
		},
		{
			MethodName: "ImportPlugin",
			Handler:    _BESSControl_ImportPlugin_Handler,
		},
		{
			MethodName: "UnloadPlugin",
			Handler:    _BESSControl_UnloadPlugin_Handler,
		},
		{
			MethodName: "ListPlugins",
			Handler:    _BESSControl_ListPlugins_Handler,
		},
		{
			MethodName: "PauseAll",
			Handler:    _BESSControl_PauseAll_Handler,
		},
		{
			MethodName: "PauseWorker",
			Handler:    _BESSControl_PauseWorker_Handler,
		},
		{
			MethodName: "ResumeWorker",
			Handler:    _BESSControl_ResumeWorker_Handler,
		},
		{
			MethodName: "ResumeAll",
			Handler:    _BESSControl_ResumeAll_Handler,
		},
		{
			MethodName: "ResetWorkers",
			Handler:    _BESSControl_ResetWorkers_Handler,
		},
		{
			MethodName: "ListWorkers",
			Handler:    _BESSControl_ListWorkers_Handler,
		},
		{
			MethodName: "AddWorker",
			Handler:    _BESSControl_AddWorker_Handler,
		},
		{
			MethodName: "DestroyWorker",
			Handler:    _BESSControl_DestroyWorker_Handler,
		},
		{
			MethodName: "ResetTcs",
			Handler:    _BESSControl_ResetTcs_Handler,
		},
		{
			MethodName: "ListTcs",
			Handler:    _BESSControl_ListTcs_Handler,
		},
		{
			MethodName: "CheckSchedulingConstraints",
			Handler:    _BESSControl_CheckSchedulingConstraints_Handler,
		},
		{
			MethodName: "AddTc",
			Handler:    _BESSControl_AddTc_Handler,
		},
		{
			MethodName: "UpdateTcParams",
			Handler:    _BESSControl_UpdateTcParams_Handler,
		},
		{
			MethodName: "UpdateTcParent",
			Handler:    _BESSControl_UpdateTcParent_Handler,
		},
		{
			MethodName: "GetTcStats",
			Handler:    _BESSControl_GetTcStats_Handler,
		},
		{
			MethodName: "ListDrivers",
			Handler:    _BESSControl_ListDrivers_Handler,
		},
		{
			MethodName: "GetDriverInfo",
			Handler:    _BESSControl_GetDriverInfo_Handler,
		},
		{
			MethodName: "ResetPorts",
			Handler:    _BESSControl_ResetPorts_Handler,
		},
		{
			MethodName: "ListPorts",
			Handler:    _BESSControl_ListPorts_Handler,
		},
		{
			MethodName: "CreatePort",
			Handler:    _BESSControl_CreatePort_Handler,
		},
		{
			MethodName: "DestroyPort",
			Handler:    _BESSControl_DestroyPort_Handler,
		},
		{
			MethodName: "SetPortConf",
			Handler:    _BESSControl_SetPortConf_Handler,
		},
		{
			MethodName: "GetPortConf",
			Handler:    _BESSControl_GetPortConf_Handler,
		},
		{
			MethodName: "GetPortStats",
			Handler:    _BESSControl_GetPortStats_Handler,
		},
		{
			MethodName: "GetLinkStatus",
			Handler:    _BESSControl_GetLinkStatus_Handler,
		},
		{
			MethodName: "ListMclass",
			Handler:    _BESSControl_ListMclass_Handler,
		},
		{
			MethodName: "GetMclassInfo",
			Handler:    _BESSControl_GetMclassInfo_Handler,
		},
		{
			MethodName: "ResetModules",
			Handler:    _BESSControl_ResetModules_Handler,
		},
		{
			MethodName: "ListModules",
			Handler:    _BESSControl_ListModules_Handler,
		},
		{
			MethodName: "CreateModule",
			Handler:    _BESSControl_CreateModule_Handler,
		},
		{
			MethodName: "DestroyModule",
			Handler:    _BESSControl_DestroyModule_Handler,
		},
		{
			MethodName: "GetModuleInfo",
			Handler:    _BESSControl_GetModuleInfo_Handler,
		},
		{
			MethodName: "ConnectModules",
			Handler:    _BESSControl_ConnectModules_Handler,
		},
		{
			MethodName: "DisconnectModules",
			Handler:    _BESSControl_DisconnectModules_Handler,
		},
		{
			MethodName: "DumpMempool",
			Handler:    _BESSControl_DumpMempool_Handler,
		},
		{
			MethodName: "ModuleCommand",
			Handler:    _BESSControl_ModuleCommand_Handler,
		},
		{
			MethodName: "ListGateHookClass",
			Handler:    _BESSControl_ListGateHookClass_Handler,
		},
		{
			MethodName: "GetGateHookClassInfo",
			Handler:    _BESSControl_GetGateHookClassInfo_Handler,
		},
		{
			MethodName: "ConfigureGateHook",
			Handler:    _BESSControl_ConfigureGateHook_Handler,
		},
		{
			MethodName: "ListGateHooks",
			Handler:    _BESSControl_ListGateHooks_Handler,
		},
		{
			MethodName: "GateHookCommand",
			Handler:    _BESSControl_GateHookCommand_Handler,
		},
		{
			MethodName: "ConfigureResumeHook",
			Handler:    _BESSControl_ConfigureResumeHook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

func init() { proto.RegisterFile("service.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 815 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4d, 0x6f, 0xdb, 0x38,
	0x10, 0xdd, 0xcb, 0x6e, 0x36, 0x74, 0x9c, 0x45, 0xb4, 0x5f, 0xad, 0x9d, 0xa4, 0x68, 0xda, 0x9e,
	0x0a, 0xf8, 0xd0, 0x5e, 0x0a, 0xf4, 0x23, 0x1f, 0x72, 0xea, 0xa4, 0x8d, 0x0b, 0xc3, 0x76, 0xd2,
	0x4b, 0x81, 0x42, 0x96, 0x26, 0x8e, 0x60, 0x89, 0x54, 0x45, 0x2a, 0x40, 0xfe, 0x66, 0x7f, 0x51,
	0x21, 0x89, 0xa6, 0x86, 0xa6, 0x14, 0x29, 0xbe, 0x25, 0xef, 0xcd, 0x3c, 0x72, 0xde, 0x0c, 0x49,
	0x99, 0xb4, 0x39, 0xc4, 0xb7, 0xbe, 0x0b, 0xbd, 0x28, 0x66, 0x82, 0x59, 0x1b, 0x33, 0xe0, 0xbc,
	0x17, 0xcd, 0x3a, 0xdb, 0xe9, 0x1f, 0xdf, 0x43, 0x3e, 0xcf, 0x89, 0x57, 0x3f, 0xbb, 0xa4, 0x75,
	0x72, 0x3a, 0x99, 0xd8, 0x8c, 0x8a, 0x98, 0x05, 0xd6, 0x21, 0x21, 0x03, 0x10, 0x57, 0x10, 0x73,
	0x9f, 0x51, 0xeb, 0xdf, 0x9e, 0xcc, 0xeb, 0x9d, 0x86, 0x91, 0xb8, 0x1b, 0xc3, 0x8f, 0x04, 0xb8,
	0xe8, 0x3c, 0x52, 0xb0, 0x0c, 0x1c, 0x03, 0x8f, 0x18, 0xe5, 0x70, 0xf0, 0x9b, 0xf5, 0x96, 0xfc,
	0x39, 0x06, 0x0e, 0xe2, 0x38, 0x08, 0xaa, 0xd2, 0xff, 0x5b, 0x85, 0x71, 0xf2, 0x67, 0x3f, 0x08,
	0x4e, 0x80, 0xf3, 0x87, 0x27, 0x7f, 0x24, 0x5b, 0xe7, 0x61, 0xc4, 0x62, 0x31, 0x0a, 0x92, 0xb9,
	0x4f, 0xad, 0x5d, 0x15, 0x89, 0xe1, 0x46, 0x3a, 0x97, 0x34, 0x60, 0x8e, 0x67, 0xe8, 0x60, 0xb8,
	0x5e, 0xa7, 0x4f, 0x5a, 0x17, 0x3e, 0x97, 0xcb, 0x56, 0xd6, 0x53, 0xa8, 0xa3, 0x60, 0xdd, 0x92,
	0x91, 0x93, 0x70, 0x58, 0xcb, 0xcf, 0x3e, 0x69, 0x65, 0xc9, 0x5f, 0x59, 0xbc, 0x80, 0xd8, 0xea,
	0xaa, 0x40, 0x84, 0x36, 0x32, 0x64, 0x0c, 0x3c, 0x09, 0x97, 0x32, 0xc5, 0x96, 0x31, 0x5c, 0xaf,
	0xf3, 0x8e, 0x6c, 0xe6, 0x09, 0x6b, 0xd5, 0x72, 0x98, 0xed, 0x02, 0x44, 0xbe, 0x1a, 0x5f, 0xcb,
	0x8c, 0xd4, 0xe2, 0x9a, 0x7c, 0xbd, 0x1f, 0x32, 0x18, 0xa9, 0x1c, 0x91, 0xcd, 0x63, 0xcf, 0x93,
	0x4e, 0x3c, 0x56, 0xc1, 0x0a, 0xab, 0xdf, 0xc7, 0x19, 0x69, 0xf7, 0x81, 0x8b, 0x98, 0xdd, 0x49,
	0x95, 0x3d, 0x15, 0xaa, 0xe1, 0x8d, 0x8e, 0x4b, 0x66, 0xc9, 0xd4, 0x5d, 0xc3, 0x8e, 0x0f, 0x64,
	0x23, 0xad, 0x30, 0xcd, 0xfd, 0x5f, 0xab, 0x79, 0xea, 0x72, 0xf3, 0xa0, 0x2b, 0x42, 0xe5, 0xcf,
	0x48, 0xc7, 0xbe, 0x01, 0x77, 0x31, 0x71, 0x6f, 0xc0, 0x4b, 0x02, 0x9f, 0xce, 0x6d, 0x46, 0xb9,
	0x88, 0x1d, 0x9f, 0x8a, 0xca, 0xed, 0xbc, 0x54, 0x70, 0x75, 0x2e, 0x5a, 0xe3, 0x0d, 0xf9, 0xfd,
	0xd8, 0xf3, 0xa6, 0x2e, 0x92, 0xcb, 0xfe, 0xaf, 0xaf, 0xee, 0x13, 0xd9, 0xbe, 0x8c, 0x3c, 0x47,
	0xc0, 0xd4, 0x1d, 0x39, 0xb1, 0x13, 0x72, 0x6b, 0xbf, 0x38, 0xc6, 0x1a, 0xf1, 0x50, 0x2d, 0xa0,
	0xa2, 0x5c, 0x0b, 0xa8, 0xa8, 0xd7, 0x1a, 0x64, 0xf7, 0xeb, 0xd4, 0x9d, 0x08, 0x47, 0x70, 0xab,
	0xa3, 0xe2, 0x0a, 0x70, 0xa9, 0xd1, 0x2d, 0xe5, 0x56, 0xa7, 0xb9, 0x1f, 0xfb, 0xb7, 0x8d, 0xa7,
	0x59, 0x06, 0x23, 0x95, 0x11, 0x69, 0x0f, 0x40, 0xe2, 0xe7, 0xf4, 0x9a, 0xa1, 0x59, 0xd4, 0xf0,
	0xa5, 0xde, 0x7e, 0x15, 0xad, 0x14, 0xdf, 0x13, 0x92, 0xcd, 0xe4, 0x88, 0xc5, 0x62, 0x8d, 0xa9,
	0x3c, 0x22, 0x9b, 0xd9, 0x3d, 0x78, 0x5f, 0x76, 0x47, 0xbf, 0x32, 0xd3, 0x50, 0xdd, 0x61, 0x3b,
	0x06, 0x47, 0x40, 0x4a, 0x20, 0x87, 0x0b, 0xd0, 0x74, 0x18, 0x73, 0xd8, 0x61, 0x79, 0x1e, 0x33,
	0xa5, 0xee, 0xea, 0x29, 0xc5, 0x52, 0xf7, 0xde, 0x3a, 0x93, 0xdc, 0x0d, 0x9b, 0xd1, 0x6b, 0xa4,
	0x82, 0xd0, 0x26, 0x23, 0xd8, 0x1a, 0x94, 0xaa, 0x0c, 0x4c, 0x95, 0xdd, 0x72, 0x52, 0x69, 0x0d,
	0xc9, 0x96, 0x24, 0xf2, 0x21, 0x34, 0xe2, 0xb5, 0x31, 0xdc, 0xab, 0x60, 0x57, 0x46, 0xe8, 0xc2,
	0xa7, 0x8b, 0x94, 0x49, 0xb8, 0x3e, 0x42, 0x05, 0x5e, 0x3a, 0x42, 0x98, 0x56, 0x8a, 0x27, 0x84,
	0xa4, 0x8d, 0x1d, 0xba, 0x81, 0x53, 0xfd, 0x1d, 0xd0, 0xd5, 0x86, 0x20, 0x8f, 0x35, 0x76, 0x95,
	0xc3, 0xe6, 0x60, 0x17, 0x78, 0xe9, 0xae, 0x30, 0x6d, 0xbc, 0x3f, 0x43, 0xe6, 0x25, 0x01, 0xac,
	0xff, 0xfe, 0xd4, 0xe4, 0xeb, 0x27, 0x56, 0x06, 0xeb, 0xdd, 0xcb, 0xa7, 0x35, 0xa7, 0x50, 0xf7,
	0x30, 0x6c, 0x76, 0x4f, 0x67, 0x4b, 0x1e, 0x23, 0xa9, 0x67, 0x3c, 0x46, 0xba, 0x60, 0x75, 0x79,
	0xd2, 0xf1, 0x2c, 0xba, 0xc4, 0x71, 0x85, 0x97, 0x3b, 0x8e, 0x68, 0x7c, 0xef, 0xda, 0x8c, 0x52,
	0x70, 0x95, 0x67, 0x45, 0x8e, 0x4e, 0x34, 0xd9, 0xdd, 0x4e, 0xdf, 0xe7, 0xae, 0x2e, 0xf7, 0xb4,
	0xa8, 0x75, 0x95, 0x6b, 0x74, 0x24, 0xfb, 0x49, 0x18, 0x0d, 0x21, 0x8c, 0x18, 0x0b, 0xf0, 0xf5,
	0x50, 0xa0, 0x66, 0x53, 0x35, 0x12, 0x8d, 0x46, 0x3b, 0x5f, 0xd7, 0x66, 0x61, 0xe8, 0x50, 0x0f,
	0xbd, 0xc8, 0x12, 0x31, 0x5f, 0x64, 0x45, 0xe0, 0x1a, 0xd3, 0x99, 0x19, 0x38, 0x02, 0xce, 0x18,
	0x5b, 0xd8, 0xf7, 0x1d, 0x9f, 0x03, 0x6d, 0xcc, 0xb4, 0x14, 0xa4, 0x08, 0xe4, 0x9f, 0x01, 0xe8,
	0x6c, 0xd6, 0xda, 0xe7, 0xb8, 0x77, 0x06, 0xbd, 0x5c, 0xe3, 0x45, 0x4d, 0x94, 0x5a, 0xe6, 0x1b,
	0xd9, 0x49, 0xef, 0x28, 0x7f, 0x9e, 0xc4, 0xb0, 0x8c, 0x43, 0xcd, 0x31, 0x38, 0xb3, 0x88, 0x92,
	0x10, 0x3c, 0xe2, 0xb8, 0xc6, 0x4a, 0x4b, 0xf6, 0x4b, 0x2d, 0xc1, 0x76, 0x7c, 0x21, 0x7f, 0xa9,
	0x32, 0x64, 0xa3, 0x9e, 0x14, 0x35, 0xea, 0x4c, 0x93, 0x86, 0x5d, 0x91, 0xbf, 0xd5, 0xc6, 0xf3,
	0x2f, 0xe3, 0xac, 0xf2, 0x67, 0x66, 0x59, 0x05, 0xdb, 0x40, 0x77, 0xf6, 0x47, 0xf6, 0xdb, 0xee,
	0xf5, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0xa4, 0xdf, 0x08, 0x05, 0x0e, 0x00, 0x00,
}
