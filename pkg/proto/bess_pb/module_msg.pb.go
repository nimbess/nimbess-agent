// Code generated by protoc-gen-go. DO NOT EDIT.
// source: module_msg.proto

package bess_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type EmptyArg struct {
}

func (m *EmptyArg) Reset()                    { *m = EmptyArg{} }
func (m *EmptyArg) String() string            { return proto.CompactTextString(m) }
func (*EmptyArg) ProtoMessage()               {}
func (*EmptyArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

// *
// The BPF module has a command `clear()` that takes no parameters.
// This command removes all filters from the module.
type BPFCommandClearArg struct {
}

func (m *BPFCommandClearArg) Reset()                    { *m = BPFCommandClearArg{} }
func (m *BPFCommandClearArg) String() string            { return proto.CompactTextString(m) }
func (*BPFCommandClearArg) ProtoMessage()               {}
func (*BPFCommandClearArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

// *
// The ExactMatch module has a command `add(...)` that takes two parameters.
// The ExactMatch initializer specifies what fields in a packet to inspect; add() specifies
// which values to check for over these fields.
// add() inserts a new rule into the ExactMatch module such that traffic matching
// that bytestring will be forwarded
// out a specified gate.
// Example use: `add(fields=[aton('12.3.4.5'), aton('5.4.3.2')], gate=2)`
type ExactMatchCommandAddArg struct {
	Gate   uint64       `protobuf:"varint,1,opt,name=gate" json:"gate,omitempty"`
	Fields []*FieldData `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty"`
}

func (m *ExactMatchCommandAddArg) Reset()                    { *m = ExactMatchCommandAddArg{} }
func (m *ExactMatchCommandAddArg) String() string            { return proto.CompactTextString(m) }
func (*ExactMatchCommandAddArg) ProtoMessage()               {}
func (*ExactMatchCommandAddArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *ExactMatchCommandAddArg) GetGate() uint64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

func (m *ExactMatchCommandAddArg) GetFields() []*FieldData {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// The ExactMatch module has a command `delete(...)` which deletes an existing rule.
// Example use: `delete(fields=[aton('12.3.4.5'), aton('5.4.3.2')])`
type ExactMatchCommandDeleteArg struct {
	Fields []*FieldData `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty"`
}

func (m *ExactMatchCommandDeleteArg) Reset()                    { *m = ExactMatchCommandDeleteArg{} }
func (m *ExactMatchCommandDeleteArg) String() string            { return proto.CompactTextString(m) }
func (*ExactMatchCommandDeleteArg) ProtoMessage()               {}
func (*ExactMatchCommandDeleteArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *ExactMatchCommandDeleteArg) GetFields() []*FieldData {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// The ExactMatch module has a command `clear()` which takes no parameters.
// This command removes all rules from the ExactMatch module.
type ExactMatchCommandClearArg struct {
}

func (m *ExactMatchCommandClearArg) Reset()                    { *m = ExactMatchCommandClearArg{} }
func (m *ExactMatchCommandClearArg) String() string            { return proto.CompactTextString(m) }
func (*ExactMatchCommandClearArg) ProtoMessage()               {}
func (*ExactMatchCommandClearArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

// *
// The ExactMatch module has a command `set_default_gate(...)` which takes one parameter.
// This command routes all traffic which does _not_ match a rule to a specified gate.
// Example use in bessctl: `setDefaultGate(gate=2)`
type ExactMatchCommandSetDefaultGateArg struct {
	Gate uint64 `protobuf:"varint,1,opt,name=gate" json:"gate,omitempty"`
}

func (m *ExactMatchCommandSetDefaultGateArg) Reset()         { *m = ExactMatchCommandSetDefaultGateArg{} }
func (m *ExactMatchCommandSetDefaultGateArg) String() string { return proto.CompactTextString(m) }
func (*ExactMatchCommandSetDefaultGateArg) ProtoMessage()    {}
func (*ExactMatchCommandSetDefaultGateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{5}
}

func (m *ExactMatchCommandSetDefaultGateArg) GetGate() uint64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

// *
// The FlowGen module has a command `set_burst(...)` that allows you to specify
// the maximum number of packets to be stored in a single PacketBatch released
// by the module.
type FlowGenCommandSetBurstArg struct {
	Burst uint64 `protobuf:"varint,1,opt,name=burst" json:"burst,omitempty"`
}

func (m *FlowGenCommandSetBurstArg) Reset()                    { *m = FlowGenCommandSetBurstArg{} }
func (m *FlowGenCommandSetBurstArg) String() string            { return proto.CompactTextString(m) }
func (*FlowGenCommandSetBurstArg) ProtoMessage()               {}
func (*FlowGenCommandSetBurstArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *FlowGenCommandSetBurstArg) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

// *
// The HashLB module has a command `set_mode(...)` which takes two parameters.
// The `mode` parameter specifies whether the load balancer will hash over the
// src/dest ethernet header (`'l2'`), over the src/dest IP addresses (`'l3'`), or over
// the flow 5-tuple (`'l4'`).  Alternatively, if the `fields` parameter is set, the
// load balancer will hash over the N-tuple with the specified offsets and
// sizes.
// Example use in bessctl: `lb.set_mode('l2')`
type HashLBCommandSetModeArg struct {
	Mode   string   `protobuf:"bytes,1,opt,name=mode" json:"mode,omitempty"`
	Fields []*Field `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty"`
}

func (m *HashLBCommandSetModeArg) Reset()                    { *m = HashLBCommandSetModeArg{} }
func (m *HashLBCommandSetModeArg) String() string            { return proto.CompactTextString(m) }
func (*HashLBCommandSetModeArg) ProtoMessage()               {}
func (*HashLBCommandSetModeArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *HashLBCommandSetModeArg) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *HashLBCommandSetModeArg) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// The HashLB module has a command `set_gates(...)` which takes one parameter.
// This function takes in a list of gate numbers to send hashed traffic out over.
// Example use in bessctl: `lb.setGates(gates=[0,1,2,3])`
type HashLBCommandSetGatesArg struct {
	Gates []int64 `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
}

func (m *HashLBCommandSetGatesArg) Reset()                    { *m = HashLBCommandSetGatesArg{} }
func (m *HashLBCommandSetGatesArg) String() string            { return proto.CompactTextString(m) }
func (*HashLBCommandSetGatesArg) ProtoMessage()               {}
func (*HashLBCommandSetGatesArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *HashLBCommandSetGatesArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

// *
// The IPLookup module has a command `add(...)` which takes three paramters.
// This function accepts the routing rules -- CIDR prefix, CIDR prefix length,
// and what gate to forward matching traffic out on.
// Example use in bessctl: `table.add(prefix='10.0.0.0', prefix_len=8, gate=2)`
type IPLookupCommandAddArg struct {
	Prefix    string `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	PrefixLen uint64 `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen" json:"prefix_len,omitempty"`
	Gate      uint64 `protobuf:"varint,3,opt,name=gate" json:"gate,omitempty"`
}

func (m *IPLookupCommandAddArg) Reset()                    { *m = IPLookupCommandAddArg{} }
func (m *IPLookupCommandAddArg) String() string            { return proto.CompactTextString(m) }
func (*IPLookupCommandAddArg) ProtoMessage()               {}
func (*IPLookupCommandAddArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *IPLookupCommandAddArg) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *IPLookupCommandAddArg) GetPrefixLen() uint64 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *IPLookupCommandAddArg) GetGate() uint64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

// *
// The IPLookup module has a command `delete(...)` which takes two paramters.
// This function accepts the routing rules -- CIDR prefix, CIDR prefix length,
// Example use in bessctl: `table.delete(prefix='10.0.0.0', prefix_len=8)`
type IPLookupCommandDeleteArg struct {
	Prefix    string `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	PrefixLen uint64 `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen" json:"prefix_len,omitempty"`
}

func (m *IPLookupCommandDeleteArg) Reset()                    { *m = IPLookupCommandDeleteArg{} }
func (m *IPLookupCommandDeleteArg) String() string            { return proto.CompactTextString(m) }
func (*IPLookupCommandDeleteArg) ProtoMessage()               {}
func (*IPLookupCommandDeleteArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

func (m *IPLookupCommandDeleteArg) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *IPLookupCommandDeleteArg) GetPrefixLen() uint64 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

// *
// The IPLookup module has a command `clear()` which takes no parameters.
// This function removes all rules in the IPLookup table.
// Example use in bessctl: `myiplookuptable.clear()`
type IPLookupCommandClearArg struct {
}

func (m *IPLookupCommandClearArg) Reset()                    { *m = IPLookupCommandClearArg{} }
func (m *IPLookupCommandClearArg) String() string            { return proto.CompactTextString(m) }
func (*IPLookupCommandClearArg) ProtoMessage()               {}
func (*IPLookupCommandClearArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

// *
// The L2Forward module forwards traffic via exact match over the Ethernet
// destination address. The command `add(...)`  allows you to specifiy a
// MAC address and which gate the L2Forward module should direct it out of.
type L2ForwardCommandAddArg struct {
	Entries []*L2ForwardCommandAddArg_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *L2ForwardCommandAddArg) Reset()                    { *m = L2ForwardCommandAddArg{} }
func (m *L2ForwardCommandAddArg) String() string            { return proto.CompactTextString(m) }
func (*L2ForwardCommandAddArg) ProtoMessage()               {}
func (*L2ForwardCommandAddArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *L2ForwardCommandAddArg) GetEntries() []*L2ForwardCommandAddArg_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type L2ForwardCommandAddArg_Entry struct {
	Addr string `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	Gate int64  `protobuf:"varint,2,opt,name=gate" json:"gate,omitempty"`
}

func (m *L2ForwardCommandAddArg_Entry) Reset()         { *m = L2ForwardCommandAddArg_Entry{} }
func (m *L2ForwardCommandAddArg_Entry) String() string { return proto.CompactTextString(m) }
func (*L2ForwardCommandAddArg_Entry) ProtoMessage()    {}
func (*L2ForwardCommandAddArg_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{12, 0}
}

func (m *L2ForwardCommandAddArg_Entry) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *L2ForwardCommandAddArg_Entry) GetGate() int64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

// *
// The L2Forward module has a function `delete(...)` to remove a rule
// from the MAC forwarding table.
type L2ForwardCommandDeleteArg struct {
	Addrs []string `protobuf:"bytes,1,rep,name=addrs" json:"addrs,omitempty"`
}

func (m *L2ForwardCommandDeleteArg) Reset()                    { *m = L2ForwardCommandDeleteArg{} }
func (m *L2ForwardCommandDeleteArg) String() string            { return proto.CompactTextString(m) }
func (*L2ForwardCommandDeleteArg) ProtoMessage()               {}
func (*L2ForwardCommandDeleteArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{13} }

func (m *L2ForwardCommandDeleteArg) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

// *
// For traffic reaching the L2Forward module which does not match a MAC rule,
// the function `set_default_gate(...)` allows you to specify a default gate
// to direct unmatched traffic to.
type L2ForwardCommandSetDefaultGateArg struct {
	Gate int64 `protobuf:"varint,1,opt,name=gate" json:"gate,omitempty"`
}

func (m *L2ForwardCommandSetDefaultGateArg) Reset()         { *m = L2ForwardCommandSetDefaultGateArg{} }
func (m *L2ForwardCommandSetDefaultGateArg) String() string { return proto.CompactTextString(m) }
func (*L2ForwardCommandSetDefaultGateArg) ProtoMessage()    {}
func (*L2ForwardCommandSetDefaultGateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{14}
}

func (m *L2ForwardCommandSetDefaultGateArg) GetGate() int64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

// *
// The L2Forward module has a function `lookup(...)` to query what output gate
// a given MAC address will be forwared to; it returns the gate ID number.
type L2ForwardCommandLookupArg struct {
	Addrs []string `protobuf:"bytes,1,rep,name=addrs" json:"addrs,omitempty"`
}

func (m *L2ForwardCommandLookupArg) Reset()                    { *m = L2ForwardCommandLookupArg{} }
func (m *L2ForwardCommandLookupArg) String() string            { return proto.CompactTextString(m) }
func (*L2ForwardCommandLookupArg) ProtoMessage()               {}
func (*L2ForwardCommandLookupArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{15} }

func (m *L2ForwardCommandLookupArg) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

// *
// This message type provides the reponse to the L2Forward function `lookup(..)`.
// It returns the gate that a requested MAC address is currently assigned to.
type L2ForwardCommandLookupResponse struct {
	Gates []uint64 `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
}

func (m *L2ForwardCommandLookupResponse) Reset()                    { *m = L2ForwardCommandLookupResponse{} }
func (m *L2ForwardCommandLookupResponse) String() string            { return proto.CompactTextString(m) }
func (*L2ForwardCommandLookupResponse) ProtoMessage()               {}
func (*L2ForwardCommandLookupResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{16} }

func (m *L2ForwardCommandLookupResponse) GetGates() []uint64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

// *
// The L2Forward module has a command `populate(...)` which allows for fast creation
// of the forwarding table given a range of MAC addresses. The function takes in a
// 'base' MAC address, a count (number of MAC addresses), and a gate_id. The module
// will route all MAC addresses starting from the base address, up to base+count address
// round-robin over gate_count total gates.
// For example, `populate(base='11:22:33:44:00', count = 10, gate_count = 2) would
// route addresses 11:22:33:44::(00, 02, 04, 06, 08) out a gate 0 and the odd-suffixed
// addresses out gate 1.
type L2ForwardCommandPopulateArg struct {
	Base      string `protobuf:"bytes,1,opt,name=base" json:"base,omitempty"`
	Count     int64  `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
	GateCount int64  `protobuf:"varint,3,opt,name=gate_count,json=gateCount" json:"gate_count,omitempty"`
}

func (m *L2ForwardCommandPopulateArg) Reset()                    { *m = L2ForwardCommandPopulateArg{} }
func (m *L2ForwardCommandPopulateArg) String() string            { return proto.CompactTextString(m) }
func (*L2ForwardCommandPopulateArg) ProtoMessage()               {}
func (*L2ForwardCommandPopulateArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{17} }

func (m *L2ForwardCommandPopulateArg) GetBase() string {
	if m != nil {
		return m.Base
	}
	return ""
}

func (m *L2ForwardCommandPopulateArg) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *L2ForwardCommandPopulateArg) GetGateCount() int64 {
	if m != nil {
		return m.GateCount
	}
	return 0
}

// *
// The Measure module measures and collects latency/jitter data for packets
// annotated by a Timestamp module. Note that Timestamp and Measure module must reside
// on the server for accurate measurement (as a result, the most typical use case is
// measuring roundtrip time).
// Optionally, you can also retrieve percentile values by specifying points in
// "percentiles". For example, "percentiles" of [50.0, 99.0] will return
// [median, 99'th %-ile tail latency] in "percentile_values_ns" in the response.
type MeasureCommandGetSummaryArg struct {
	Clear              bool      `protobuf:"varint,1,opt,name=clear" json:"clear,omitempty"`
	LatencyPercentiles []float64 `protobuf:"fixed64,2,rep,packed,name=latency_percentiles,json=latencyPercentiles" json:"latency_percentiles,omitempty"`
	JitterPercentiles  []float64 `protobuf:"fixed64,3,rep,packed,name=jitter_percentiles,json=jitterPercentiles" json:"jitter_percentiles,omitempty"`
}

func (m *MeasureCommandGetSummaryArg) Reset()                    { *m = MeasureCommandGetSummaryArg{} }
func (m *MeasureCommandGetSummaryArg) String() string            { return proto.CompactTextString(m) }
func (*MeasureCommandGetSummaryArg) ProtoMessage()               {}
func (*MeasureCommandGetSummaryArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{18} }

func (m *MeasureCommandGetSummaryArg) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

func (m *MeasureCommandGetSummaryArg) GetLatencyPercentiles() []float64 {
	if m != nil {
		return m.LatencyPercentiles
	}
	return nil
}

func (m *MeasureCommandGetSummaryArg) GetJitterPercentiles() []float64 {
	if m != nil {
		return m.JitterPercentiles
	}
	return nil
}

// *
// The Measure module function `get_summary()` returns the following values.
// Note that the resolution value tells you how grainy the samples are,
// e.g., 100 means that anything from 0-99 ns counts as "0",
// anything from 100-199 counts as "100", and so on.  The average
// is of samples using this graininess, but (being a result of division)
// may not be a multiple of the resolution.
type MeasureCommandGetSummaryResponse struct {
	Timestamp float64                                     `protobuf:"fixed64,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Packets   uint64                                      `protobuf:"varint,2,opt,name=packets" json:"packets,omitempty"`
	Bits      uint64                                      `protobuf:"varint,3,opt,name=bits" json:"bits,omitempty"`
	Latency   *MeasureCommandGetSummaryResponse_Histogram `protobuf:"bytes,4,opt,name=latency" json:"latency,omitempty"`
	Jitter    *MeasureCommandGetSummaryResponse_Histogram `protobuf:"bytes,5,opt,name=jitter" json:"jitter,omitempty"`
}

func (m *MeasureCommandGetSummaryResponse) Reset()         { *m = MeasureCommandGetSummaryResponse{} }
func (m *MeasureCommandGetSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*MeasureCommandGetSummaryResponse) ProtoMessage()    {}
func (*MeasureCommandGetSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{19}
}

func (m *MeasureCommandGetSummaryResponse) GetTimestamp() float64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse) GetPackets() uint64 {
	if m != nil {
		return m.Packets
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse) GetBits() uint64 {
	if m != nil {
		return m.Bits
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse) GetLatency() *MeasureCommandGetSummaryResponse_Histogram {
	if m != nil {
		return m.Latency
	}
	return nil
}

func (m *MeasureCommandGetSummaryResponse) GetJitter() *MeasureCommandGetSummaryResponse_Histogram {
	if m != nil {
		return m.Jitter
	}
	return nil
}

type MeasureCommandGetSummaryResponse_Histogram struct {
	Count              uint64   `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	AboveRange         uint64   `protobuf:"varint,2,opt,name=above_range,json=aboveRange" json:"above_range,omitempty"`
	ResolutionNs       uint64   `protobuf:"varint,8,opt,name=resolution_ns,json=resolutionNs" json:"resolution_ns,omitempty"`
	MinNs              uint64   `protobuf:"varint,3,opt,name=min_ns,json=minNs" json:"min_ns,omitempty"`
	AvgNs              uint64   `protobuf:"varint,4,opt,name=avg_ns,json=avgNs" json:"avg_ns,omitempty"`
	MaxNs              uint64   `protobuf:"varint,5,opt,name=max_ns,json=maxNs" json:"max_ns,omitempty"`
	TotalNs            uint64   `protobuf:"varint,6,opt,name=total_ns,json=totalNs" json:"total_ns,omitempty"`
	PercentileValuesNs []uint64 `protobuf:"varint,7,rep,packed,name=percentile_values_ns,json=percentileValuesNs" json:"percentile_values_ns,omitempty"`
}

func (m *MeasureCommandGetSummaryResponse_Histogram) Reset() {
	*m = MeasureCommandGetSummaryResponse_Histogram{}
}
func (m *MeasureCommandGetSummaryResponse_Histogram) String() string {
	return proto.CompactTextString(m)
}
func (*MeasureCommandGetSummaryResponse_Histogram) ProtoMessage() {}
func (*MeasureCommandGetSummaryResponse_Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{19, 0}
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetAboveRange() uint64 {
	if m != nil {
		return m.AboveRange
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetResolutionNs() uint64 {
	if m != nil {
		return m.ResolutionNs
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetMinNs() uint64 {
	if m != nil {
		return m.MinNs
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetAvgNs() uint64 {
	if m != nil {
		return m.AvgNs
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetMaxNs() uint64 {
	if m != nil {
		return m.MaxNs
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetTotalNs() uint64 {
	if m != nil {
		return m.TotalNs
	}
	return 0
}

func (m *MeasureCommandGetSummaryResponse_Histogram) GetPercentileValuesNs() []uint64 {
	if m != nil {
		return m.PercentileValuesNs
	}
	return nil
}

// *
// The Module DRR provides fair scheduling of flows based on a quantum which is
// number of bytes allocated to each flow on each round of going through all flows.
// Examples can be found [./bessctl/conf/samples/drr.bess]
//
// __Input_Gates__: 1
// __Output_Gates__:  1
type DRRArg struct {
	NumFlows         uint32 `protobuf:"varint,1,opt,name=num_flows,json=numFlows" json:"num_flows,omitempty"`
	Quantum          uint64 `protobuf:"varint,2,opt,name=quantum" json:"quantum,omitempty"`
	MaxFlowQueueSize uint32 `protobuf:"varint,3,opt,name=max_flow_queue_size,json=maxFlowQueueSize" json:"max_flow_queue_size,omitempty"`
}

func (m *DRRArg) Reset()                    { *m = DRRArg{} }
func (m *DRRArg) String() string            { return proto.CompactTextString(m) }
func (*DRRArg) ProtoMessage()               {}
func (*DRRArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{20} }

func (m *DRRArg) GetNumFlows() uint32 {
	if m != nil {
		return m.NumFlows
	}
	return 0
}

func (m *DRRArg) GetQuantum() uint64 {
	if m != nil {
		return m.Quantum
	}
	return 0
}

func (m *DRRArg) GetMaxFlowQueueSize() uint32 {
	if m != nil {
		return m.MaxFlowQueueSize
	}
	return 0
}

// *
// the SetQuantumSize function sets a new quantum for DRR module to operate on.
type DRRQuantumArg struct {
	Quantum uint32 `protobuf:"varint,1,opt,name=quantum" json:"quantum,omitempty"`
}

func (m *DRRQuantumArg) Reset()                    { *m = DRRQuantumArg{} }
func (m *DRRQuantumArg) String() string            { return proto.CompactTextString(m) }
func (*DRRQuantumArg) ProtoMessage()               {}
func (*DRRQuantumArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{21} }

func (m *DRRQuantumArg) GetQuantum() uint32 {
	if m != nil {
		return m.Quantum
	}
	return 0
}

// *
// The SetMaxQueueSize function sets a new maximum flow queue size for DRR module.
// If the flow's queue gets to this size, the module starts dropping packets to
// that flow until the queue is below this size.
type DRRMaxFlowQueueSizeArg struct {
	MaxQueueSize uint32 `protobuf:"varint,1,opt,name=max_queue_size,json=maxQueueSize" json:"max_queue_size,omitempty"`
}

func (m *DRRMaxFlowQueueSizeArg) Reset()                    { *m = DRRMaxFlowQueueSizeArg{} }
func (m *DRRMaxFlowQueueSizeArg) String() string            { return proto.CompactTextString(m) }
func (*DRRMaxFlowQueueSizeArg) ProtoMessage()               {}
func (*DRRMaxFlowQueueSizeArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{22} }

func (m *DRRMaxFlowQueueSizeArg) GetMaxQueueSize() uint32 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

// *
// The module PortInc has a function `set_burst(...)` that allows you to specify the
// maximum number of packets to be stored in a single PacketBatch released by
// the module.
type PortIncCommandSetBurstArg struct {
	Burst uint64 `protobuf:"varint,1,opt,name=burst" json:"burst,omitempty"`
}

func (m *PortIncCommandSetBurstArg) Reset()                    { *m = PortIncCommandSetBurstArg{} }
func (m *PortIncCommandSetBurstArg) String() string            { return proto.CompactTextString(m) }
func (*PortIncCommandSetBurstArg) ProtoMessage()               {}
func (*PortIncCommandSetBurstArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{23} }

func (m *PortIncCommandSetBurstArg) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

// *
// The module QueueInc has a function `set_burst(...)` that allows you to specify
// the maximum number of packets to be stored in a single PacketBatch released
// by the module.
type QueueIncCommandSetBurstArg struct {
	Burst uint64 `protobuf:"varint,1,opt,name=burst" json:"burst,omitempty"`
}

func (m *QueueIncCommandSetBurstArg) Reset()                    { *m = QueueIncCommandSetBurstArg{} }
func (m *QueueIncCommandSetBurstArg) String() string            { return proto.CompactTextString(m) }
func (*QueueIncCommandSetBurstArg) ProtoMessage()               {}
func (*QueueIncCommandSetBurstArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{24} }

func (m *QueueIncCommandSetBurstArg) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

// *
// The module Queue has a function `set_burst(...)` that allows you to specify
// the maximum number of packets to be stored in a single PacketBatch released
// by the module.
type QueueCommandSetBurstArg struct {
	Burst uint64 `protobuf:"varint,1,opt,name=burst" json:"burst,omitempty"`
}

func (m *QueueCommandSetBurstArg) Reset()                    { *m = QueueCommandSetBurstArg{} }
func (m *QueueCommandSetBurstArg) String() string            { return proto.CompactTextString(m) }
func (*QueueCommandSetBurstArg) ProtoMessage()               {}
func (*QueueCommandSetBurstArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{25} }

func (m *QueueCommandSetBurstArg) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

// *
// The module Queue has a function `set_size(...)` that allows specifying the
// size of the queue in total number of packets.
type QueueCommandSetSizeArg struct {
	Size uint64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
}

func (m *QueueCommandSetSizeArg) Reset()                    { *m = QueueCommandSetSizeArg{} }
func (m *QueueCommandSetSizeArg) String() string            { return proto.CompactTextString(m) }
func (*QueueCommandSetSizeArg) ProtoMessage()               {}
func (*QueueCommandSetSizeArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{26} }

func (m *QueueCommandSetSizeArg) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

// *
// Modules that are queues or contain queues may contain functions
// `get_status()` that return QueueCommandGetStatusResponse.
type QueueCommandGetStatusArg struct {
}

func (m *QueueCommandGetStatusArg) Reset()                    { *m = QueueCommandGetStatusArg{} }
func (m *QueueCommandGetStatusArg) String() string            { return proto.CompactTextString(m) }
func (*QueueCommandGetStatusArg) ProtoMessage()               {}
func (*QueueCommandGetStatusArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{27} }

// *
// Modules that are queues or contain queues may contain functions
// `get_status()` that take no parameters and returns the queue occupancy and
// size.
type QueueCommandGetStatusResponse struct {
	Count    uint64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	Size     uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	Enqueued uint64 `protobuf:"varint,3,opt,name=enqueued" json:"enqueued,omitempty"`
	Dequeued uint64 `protobuf:"varint,4,opt,name=dequeued" json:"dequeued,omitempty"`
	Dropped  uint64 `protobuf:"varint,5,opt,name=dropped" json:"dropped,omitempty"`
}

func (m *QueueCommandGetStatusResponse) Reset()                    { *m = QueueCommandGetStatusResponse{} }
func (m *QueueCommandGetStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueCommandGetStatusResponse) ProtoMessage()               {}
func (*QueueCommandGetStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{28} }

func (m *QueueCommandGetStatusResponse) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *QueueCommandGetStatusResponse) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *QueueCommandGetStatusResponse) GetEnqueued() uint64 {
	if m != nil {
		return m.Enqueued
	}
	return 0
}

func (m *QueueCommandGetStatusResponse) GetDequeued() uint64 {
	if m != nil {
		return m.Dequeued
	}
	return 0
}

func (m *QueueCommandGetStatusResponse) GetDropped() uint64 {
	if m != nil {
		return m.Dropped
	}
	return 0
}

// *
// The function `clear()` for RandomUpdate takes no parameters and clears all
// state in the module.
type RandomUpdateCommandClearArg struct {
}

func (m *RandomUpdateCommandClearArg) Reset()                    { *m = RandomUpdateCommandClearArg{} }
func (m *RandomUpdateCommandClearArg) String() string            { return proto.CompactTextString(m) }
func (*RandomUpdateCommandClearArg) ProtoMessage()               {}
func (*RandomUpdateCommandClearArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{29} }

// *
// The function `clear()` for Rewrite takes no parameters and clears all state
// in the module.
type RewriteCommandClearArg struct {
}

func (m *RewriteCommandClearArg) Reset()                    { *m = RewriteCommandClearArg{} }
func (m *RewriteCommandClearArg) String() string            { return proto.CompactTextString(m) }
func (*RewriteCommandClearArg) ProtoMessage()               {}
func (*RewriteCommandClearArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{30} }

// *
// The function `clear()` for Update takes no parameters and clears all state in
// the module.
type UpdateCommandClearArg struct {
}

func (m *UpdateCommandClearArg) Reset()                    { *m = UpdateCommandClearArg{} }
func (m *UpdateCommandClearArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateCommandClearArg) ProtoMessage()               {}
func (*UpdateCommandClearArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{31} }

// *
// The module WildcardMatch has a command `add(...)` which inserts a new rule
// into the WildcardMatch module. For an example of code using WilcardMatch see
// `bess/bessctl/conf/samples/wildcardmatch.bess`.
type WildcardMatchCommandAddArg struct {
	Gate     uint64       `protobuf:"varint,1,opt,name=gate" json:"gate,omitempty"`
	Priority int64        `protobuf:"varint,2,opt,name=priority" json:"priority,omitempty"`
	Values   []*FieldData `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
	Masks    []*FieldData `protobuf:"bytes,4,rep,name=masks" json:"masks,omitempty"`
}

func (m *WildcardMatchCommandAddArg) Reset()                    { *m = WildcardMatchCommandAddArg{} }
func (m *WildcardMatchCommandAddArg) String() string            { return proto.CompactTextString(m) }
func (*WildcardMatchCommandAddArg) ProtoMessage()               {}
func (*WildcardMatchCommandAddArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{32} }

func (m *WildcardMatchCommandAddArg) GetGate() uint64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

func (m *WildcardMatchCommandAddArg) GetPriority() int64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *WildcardMatchCommandAddArg) GetValues() []*FieldData {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *WildcardMatchCommandAddArg) GetMasks() []*FieldData {
	if m != nil {
		return m.Masks
	}
	return nil
}

// *
// The module WildcardMatch has a command `delete(...)` which removes a rule -- simply specify the values and masks from the previously inserted rule to remove them.
type WildcardMatchCommandDeleteArg struct {
	Values []*FieldData `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
	Masks  []*FieldData `protobuf:"bytes,2,rep,name=masks" json:"masks,omitempty"`
}

func (m *WildcardMatchCommandDeleteArg) Reset()                    { *m = WildcardMatchCommandDeleteArg{} }
func (m *WildcardMatchCommandDeleteArg) String() string            { return proto.CompactTextString(m) }
func (*WildcardMatchCommandDeleteArg) ProtoMessage()               {}
func (*WildcardMatchCommandDeleteArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{33} }

func (m *WildcardMatchCommandDeleteArg) GetValues() []*FieldData {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *WildcardMatchCommandDeleteArg) GetMasks() []*FieldData {
	if m != nil {
		return m.Masks
	}
	return nil
}

// *
// The function `clear()` for WildcardMatch takes no parameters, it clears
// all state in the WildcardMatch module (is equivalent to calling delete for all rules)
type WildcardMatchCommandClearArg struct {
}

func (m *WildcardMatchCommandClearArg) Reset()                    { *m = WildcardMatchCommandClearArg{} }
func (m *WildcardMatchCommandClearArg) String() string            { return proto.CompactTextString(m) }
func (*WildcardMatchCommandClearArg) ProtoMessage()               {}
func (*WildcardMatchCommandClearArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{34} }

// *
// For traffic which does not match any rule in the WildcardMatch module,
// the `set_default_gate(...)` function specifies which gate to send this extra traffic to.
type WildcardMatchCommandSetDefaultGateArg struct {
	Gate uint64 `protobuf:"varint,1,opt,name=gate" json:"gate,omitempty"`
}

func (m *WildcardMatchCommandSetDefaultGateArg) Reset()         { *m = WildcardMatchCommandSetDefaultGateArg{} }
func (m *WildcardMatchCommandSetDefaultGateArg) String() string { return proto.CompactTextString(m) }
func (*WildcardMatchCommandSetDefaultGateArg) ProtoMessage()    {}
func (*WildcardMatchCommandSetDefaultGateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{35}
}

func (m *WildcardMatchCommandSetDefaultGateArg) GetGate() uint64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

// *
// The module ACL creates an access control module which by default blocks all traffic, unless it contains a rule which specifies otherwise.
// Examples of ACL can be found in [acl.bess](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/acl.bess)
//
// __Input Gates__: 1
// __Output Gates__: 1
type ACLArg struct {
	Rules []*ACLArg_Rule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *ACLArg) Reset()                    { *m = ACLArg{} }
func (m *ACLArg) String() string            { return proto.CompactTextString(m) }
func (*ACLArg) ProtoMessage()               {}
func (*ACLArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{36} }

func (m *ACLArg) GetRules() []*ACLArg_Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// *
// One ACL rule is represented by the following 6-tuple.
type ACLArg_Rule struct {
	SrcIp       string `protobuf:"bytes,1,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	DstIp       string `protobuf:"bytes,2,opt,name=dst_ip,json=dstIp" json:"dst_ip,omitempty"`
	SrcPort     uint32 `protobuf:"varint,3,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	DstPort     uint32 `protobuf:"varint,4,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	Established bool   `protobuf:"varint,5,opt,name=established" json:"established,omitempty"`
	Drop        bool   `protobuf:"varint,6,opt,name=drop" json:"drop,omitempty"`
}

func (m *ACLArg_Rule) Reset()                    { *m = ACLArg_Rule{} }
func (m *ACLArg_Rule) String() string            { return proto.CompactTextString(m) }
func (*ACLArg_Rule) ProtoMessage()               {}
func (*ACLArg_Rule) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{36, 0} }

func (m *ACLArg_Rule) GetSrcIp() string {
	if m != nil {
		return m.SrcIp
	}
	return ""
}

func (m *ACLArg_Rule) GetDstIp() string {
	if m != nil {
		return m.DstIp
	}
	return ""
}

func (m *ACLArg_Rule) GetSrcPort() uint32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *ACLArg_Rule) GetDstPort() uint32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *ACLArg_Rule) GetEstablished() bool {
	if m != nil {
		return m.Established
	}
	return false
}

func (m *ACLArg_Rule) GetDrop() bool {
	if m != nil {
		return m.Drop
	}
	return false
}

// *
// The BPF module is an access control module that sends packets out on a particular gate based on whether they match a BPF filter.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type BPFArg struct {
	Filters []*BPFArg_Filter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
}

func (m *BPFArg) Reset()                    { *m = BPFArg{} }
func (m *BPFArg) String() string            { return proto.CompactTextString(m) }
func (*BPFArg) ProtoMessage()               {}
func (*BPFArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{37} }

func (m *BPFArg) GetFilters() []*BPFArg_Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// *
// One BPF filter is represented by the following 3-tuple.
type BPFArg_Filter struct {
	Priority int64  `protobuf:"varint,1,opt,name=priority" json:"priority,omitempty"`
	Filter   string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	Gate     int64  `protobuf:"varint,3,opt,name=gate" json:"gate,omitempty"`
}

func (m *BPFArg_Filter) Reset()                    { *m = BPFArg_Filter{} }
func (m *BPFArg_Filter) String() string            { return proto.CompactTextString(m) }
func (*BPFArg_Filter) ProtoMessage()               {}
func (*BPFArg_Filter) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{37, 0} }

func (m *BPFArg_Filter) GetPriority() int64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *BPFArg_Filter) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *BPFArg_Filter) GetGate() int64 {
	if m != nil {
		return m.Gate
	}
	return 0
}

// *
// The Buffer module takes no parameters to initialize (ie, `Buffer()` is sufficient to create one).
// Buffer accepts packets and stores them; it may forward them to the next module only after it has
// received enough packets to fill an entire PacketBatch.
//
// __Input Gates__: 1
// __Output Gates__: 1
type BufferArg struct {
}

func (m *BufferArg) Reset()                    { *m = BufferArg{} }
func (m *BufferArg) String() string            { return proto.CompactTextString(m) }
func (*BufferArg) ProtoMessage()               {}
func (*BufferArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{38} }

// *
// The Bypass module forwards packets by emulating pre-defined packet processing overhead.
// It burns cpu cycles per_batch, per_packet, and per-bytes.
// Bypass is useful primarily for testing and performance evaluation.
//
// __Input Gates__: 1
// __Output Gates__: 1
type BypassArg struct {
	CyclesPerBatch  uint32 `protobuf:"varint,1,opt,name=cycles_per_batch,json=cyclesPerBatch" json:"cycles_per_batch,omitempty"`
	CyclesPerPacket uint32 `protobuf:"varint,2,opt,name=cycles_per_packet,json=cyclesPerPacket" json:"cycles_per_packet,omitempty"`
	CyclesPerByte   uint32 `protobuf:"varint,3,opt,name=cycles_per_byte,json=cyclesPerByte" json:"cycles_per_byte,omitempty"`
}

func (m *BypassArg) Reset()                    { *m = BypassArg{} }
func (m *BypassArg) String() string            { return proto.CompactTextString(m) }
func (*BypassArg) ProtoMessage()               {}
func (*BypassArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{39} }

func (m *BypassArg) GetCyclesPerBatch() uint32 {
	if m != nil {
		return m.CyclesPerBatch
	}
	return 0
}

func (m *BypassArg) GetCyclesPerPacket() uint32 {
	if m != nil {
		return m.CyclesPerPacket
	}
	return 0
}

func (m *BypassArg) GetCyclesPerByte() uint32 {
	if m != nil {
		return m.CyclesPerByte
	}
	return 0
}

// *
// The Dump module blindly forwards packets without modifying them. It periodically samples a packet and prints out out to the BESS log (by default stored in `/tmp/bessd.INFO`).
//
// __Input Gates__: 1
// __Output Gates__: 1
type DumpArg struct {
	Interval float64 `protobuf:"fixed64,1,opt,name=interval" json:"interval,omitempty"`
}

func (m *DumpArg) Reset()                    { *m = DumpArg{} }
func (m *DumpArg) String() string            { return proto.CompactTextString(m) }
func (*DumpArg) ProtoMessage()               {}
func (*DumpArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{40} }

func (m *DumpArg) GetInterval() float64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

// *
// The EtherEncap module wraps packets in an Ethernet header, but it takes no parameters. Instead, Ethernet source, destination, and type are pulled from a packet's metadata attributes.
// For example: `SetMetadata('dst_mac', 11:22:33:44:55) -> EtherEncap()`
// This is useful when upstream modules wish to assign a MAC address to a packet, e.g., due to an ARP request.
//
// __Input Gates__: 1
// __Output Gates__: 1
type EtherEncapArg struct {
}

func (m *EtherEncapArg) Reset()                    { *m = EtherEncapArg{} }
func (m *EtherEncapArg) String() string            { return proto.CompactTextString(m) }
func (*EtherEncapArg) ProtoMessage()               {}
func (*EtherEncapArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{41} }

// *
// The ExactMatch module splits packets along output gates according to exact match values in arbitrary packet fields.
// To instantiate an ExactMatch module, you must specify which fields in the packet to match over. You can add rules using the function `ExactMatch.add(...)`
// Fields may be stored either in the packet data or its metadata attributes.
// An example script using the ExactMatch code is found
// in [`bess/bessctl/conf/samples/exactmatch.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/exactmatch.bess).
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type ExactMatchArg struct {
	Fields []*Field     `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	Masks  []*FieldData `protobuf:"bytes,2,rep,name=masks" json:"masks,omitempty"`
}

func (m *ExactMatchArg) Reset()                    { *m = ExactMatchArg{} }
func (m *ExactMatchArg) String() string            { return proto.CompactTextString(m) }
func (*ExactMatchArg) ProtoMessage()               {}
func (*ExactMatchArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{42} }

func (m *ExactMatchArg) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *ExactMatchArg) GetMasks() []*FieldData {
	if m != nil {
		return m.Masks
	}
	return nil
}

// *
// ExactMatchConfig represents the current runtime configuration
// of an ExactMatch module, as returned by get_runtime_config and
// set by set_runtime_config.
type ExactMatchConfig struct {
	DefaultGate uint64                     `protobuf:"varint,1,opt,name=default_gate,json=defaultGate" json:"default_gate,omitempty"`
	Rules       []*ExactMatchCommandAddArg `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
}

func (m *ExactMatchConfig) Reset()                    { *m = ExactMatchConfig{} }
func (m *ExactMatchConfig) String() string            { return proto.CompactTextString(m) }
func (*ExactMatchConfig) ProtoMessage()               {}
func (*ExactMatchConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{43} }

func (m *ExactMatchConfig) GetDefaultGate() uint64 {
	if m != nil {
		return m.DefaultGate
	}
	return 0
}

func (m *ExactMatchConfig) GetRules() []*ExactMatchCommandAddArg {
	if m != nil {
		return m.Rules
	}
	return nil
}

// *
// The FlowGen module generates simulated TCP flows of packets with correct SYN/FIN flags and sequence numbers.
// This module is useful for testing, e.g., a NAT module or other flow-aware code.
// Packets are generated off a base, "template" packet by modifying the IP src/dst and TCP src/dst. By default, only the ports are changed and will be modified by incrementing the template ports by up to 20000 more than the template values.
//
// __Input Gates__: 0
// __Output Gates__: 1
type FlowGenArg struct {
	Template     []byte  `protobuf:"bytes,1,opt,name=template,proto3" json:"template,omitempty"`
	Pps          float64 `protobuf:"fixed64,2,opt,name=pps" json:"pps,omitempty"`
	FlowRate     float64 `protobuf:"fixed64,3,opt,name=flow_rate,json=flowRate" json:"flow_rate,omitempty"`
	FlowDuration float64 `protobuf:"fixed64,4,opt,name=flow_duration,json=flowDuration" json:"flow_duration,omitempty"`
	Arrival      string  `protobuf:"bytes,5,opt,name=arrival" json:"arrival,omitempty"`
	Duration     string  `protobuf:"bytes,6,opt,name=duration" json:"duration,omitempty"`
	QuickRampup  bool    `protobuf:"varint,7,opt,name=quick_rampup,json=quickRampup" json:"quick_rampup,omitempty"`
	IpSrcRange   uint32  `protobuf:"varint,8,opt,name=ip_src_range,json=ipSrcRange" json:"ip_src_range,omitempty"`
	IpDstRange   uint32  `protobuf:"varint,9,opt,name=ip_dst_range,json=ipDstRange" json:"ip_dst_range,omitempty"`
	PortSrcRange uint32  `protobuf:"varint,10,opt,name=port_src_range,json=portSrcRange" json:"port_src_range,omitempty"`
	PortDstRange uint32  `protobuf:"varint,11,opt,name=port_dst_range,json=portDstRange" json:"port_dst_range,omitempty"`
}

func (m *FlowGenArg) Reset()                    { *m = FlowGenArg{} }
func (m *FlowGenArg) String() string            { return proto.CompactTextString(m) }
func (*FlowGenArg) ProtoMessage()               {}
func (*FlowGenArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{44} }

func (m *FlowGenArg) GetTemplate() []byte {
	if m != nil {
		return m.Template
	}
	return nil
}

func (m *FlowGenArg) GetPps() float64 {
	if m != nil {
		return m.Pps
	}
	return 0
}

func (m *FlowGenArg) GetFlowRate() float64 {
	if m != nil {
		return m.FlowRate
	}
	return 0
}

func (m *FlowGenArg) GetFlowDuration() float64 {
	if m != nil {
		return m.FlowDuration
	}
	return 0
}

func (m *FlowGenArg) GetArrival() string {
	if m != nil {
		return m.Arrival
	}
	return ""
}

func (m *FlowGenArg) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *FlowGenArg) GetQuickRampup() bool {
	if m != nil {
		return m.QuickRampup
	}
	return false
}

func (m *FlowGenArg) GetIpSrcRange() uint32 {
	if m != nil {
		return m.IpSrcRange
	}
	return 0
}

func (m *FlowGenArg) GetIpDstRange() uint32 {
	if m != nil {
		return m.IpDstRange
	}
	return 0
}

func (m *FlowGenArg) GetPortSrcRange() uint32 {
	if m != nil {
		return m.PortSrcRange
	}
	return 0
}

func (m *FlowGenArg) GetPortDstRange() uint32 {
	if m != nil {
		return m.PortDstRange
	}
	return 0
}

// *
// The GenericDecap module strips off the first few bytes of data from a packet.
//
// __Input Gates__: 1
// __Ouptut Gates__: 1
type GenericDecapArg struct {
	Bytes uint64 `protobuf:"varint,1,opt,name=bytes" json:"bytes,omitempty"`
}

func (m *GenericDecapArg) Reset()                    { *m = GenericDecapArg{} }
func (m *GenericDecapArg) String() string            { return proto.CompactTextString(m) }
func (*GenericDecapArg) ProtoMessage()               {}
func (*GenericDecapArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{45} }

func (m *GenericDecapArg) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

// *
// The GenericEncap module adds a header to packets passing through it.
// Takes a list of fields. Each field is either:
//
//  1. {'size': X, 'value': Y}          (for constant values)
//  2. {'size': X, 'attribute': Y}      (for metadata attributes)
//
// e.g.: `GenericEncap([{'size': 4, 'value': 0xdeadbeef},
//                      {'size': 2, 'attribute': 'foo'},
//                      {'size': 2, 'value': 0x1234}])`
// will prepend a 8-byte header:
//    `de ad be ef <xx> <xx> 12 34`
// where the 2-byte `<xx> <xx>` comes from the value of metadata attribute `'foo'`
// for each packet.
// An example script using GenericEncap is in [`bess/bessctl/conf/samples/generic_encap.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/generic_encap.bess).
//
// __Input Gates__: 1
// __Output Gates__: 1
type GenericEncapArg struct {
	Fields []*GenericEncapArg_EncapField `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
}

func (m *GenericEncapArg) Reset()                    { *m = GenericEncapArg{} }
func (m *GenericEncapArg) String() string            { return proto.CompactTextString(m) }
func (*GenericEncapArg) ProtoMessage()               {}
func (*GenericEncapArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{46} }

func (m *GenericEncapArg) GetFields() []*GenericEncapArg_EncapField {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// An EncapField represents one field in the new packet header.
type GenericEncapArg_EncapField struct {
	Size uint64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	// Types that are valid to be assigned to Insertion:
	//	*GenericEncapArg_EncapField_Attribute
	//	*GenericEncapArg_EncapField_Value
	Insertion isGenericEncapArg_EncapField_Insertion `protobuf_oneof:"insertion"`
}

func (m *GenericEncapArg_EncapField) Reset()                    { *m = GenericEncapArg_EncapField{} }
func (m *GenericEncapArg_EncapField) String() string            { return proto.CompactTextString(m) }
func (*GenericEncapArg_EncapField) ProtoMessage()               {}
func (*GenericEncapArg_EncapField) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{46, 0} }

type isGenericEncapArg_EncapField_Insertion interface{ isGenericEncapArg_EncapField_Insertion() }

type GenericEncapArg_EncapField_Attribute struct {
	Attribute string `protobuf:"bytes,2,opt,name=attribute,oneof"`
}
type GenericEncapArg_EncapField_Value struct {
	Value *FieldData `protobuf:"bytes,3,opt,name=value,oneof"`
}

func (*GenericEncapArg_EncapField_Attribute) isGenericEncapArg_EncapField_Insertion() {}
func (*GenericEncapArg_EncapField_Value) isGenericEncapArg_EncapField_Insertion()     {}

func (m *GenericEncapArg_EncapField) GetInsertion() isGenericEncapArg_EncapField_Insertion {
	if m != nil {
		return m.Insertion
	}
	return nil
}

func (m *GenericEncapArg_EncapField) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *GenericEncapArg_EncapField) GetAttribute() string {
	if x, ok := m.GetInsertion().(*GenericEncapArg_EncapField_Attribute); ok {
		return x.Attribute
	}
	return ""
}

func (m *GenericEncapArg_EncapField) GetValue() *FieldData {
	if x, ok := m.GetInsertion().(*GenericEncapArg_EncapField_Value); ok {
		return x.Value
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GenericEncapArg_EncapField) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GenericEncapArg_EncapField_OneofMarshaler, _GenericEncapArg_EncapField_OneofUnmarshaler, _GenericEncapArg_EncapField_OneofSizer, []interface{}{
		(*GenericEncapArg_EncapField_Attribute)(nil),
		(*GenericEncapArg_EncapField_Value)(nil),
	}
}

func _GenericEncapArg_EncapField_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GenericEncapArg_EncapField)
	// insertion
	switch x := m.Insertion.(type) {
	case *GenericEncapArg_EncapField_Attribute:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Attribute)
	case *GenericEncapArg_EncapField_Value:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Value); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GenericEncapArg_EncapField.Insertion has unexpected type %T", x)
	}
	return nil
}

func _GenericEncapArg_EncapField_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GenericEncapArg_EncapField)
	switch tag {
	case 2: // insertion.attribute
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Insertion = &GenericEncapArg_EncapField_Attribute{x}
		return true, err
	case 3: // insertion.value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldData)
		err := b.DecodeMessage(msg)
		m.Insertion = &GenericEncapArg_EncapField_Value{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GenericEncapArg_EncapField_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GenericEncapArg_EncapField)
	// insertion
	switch x := m.Insertion.(type) {
	case *GenericEncapArg_EncapField_Attribute:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Attribute)))
		n += len(x.Attribute)
	case *GenericEncapArg_EncapField_Value:
		s := proto.Size(x.Value)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// The HashLB module partitions packets between output gates according to either
// a hash over their MAC src/dst (`mode='l2'`), their IP src/dst (`mode='l3'`), the full
// IP/TCP 5-tuple (`mode='l4'`), or the N-tuple defined by `fields`.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type HashLBArg struct {
	Gates  []int64  `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
	Mode   string   `protobuf:"bytes,2,opt,name=mode" json:"mode,omitempty"`
	Fields []*Field `protobuf:"bytes,3,rep,name=fields" json:"fields,omitempty"`
}

func (m *HashLBArg) Reset()                    { *m = HashLBArg{} }
func (m *HashLBArg) String() string            { return proto.CompactTextString(m) }
func (*HashLBArg) ProtoMessage()               {}
func (*HashLBArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{47} }

func (m *HashLBArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

func (m *HashLBArg) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *HashLBArg) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// Encapsulates a packet with an IP header, where IP src, dst, and proto are filled in
// by metadata values carried with the packet. Metadata attributes must include:
// ip_src, ip_dst, ip_proto, ip_nexthop, and ether_type.
//
// __Input Gates__: 1
// __Output Gates__: 1
type IPEncapArg struct {
}

func (m *IPEncapArg) Reset()                    { *m = IPEncapArg{} }
func (m *IPEncapArg) String() string            { return proto.CompactTextString(m) }
func (*IPEncapArg) ProtoMessage()               {}
func (*IPEncapArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{48} }

// *
// An IPLookup module perfroms LPM lookups over a packet destination.
// IPLookup takes no parameters to instantiate.
// To add rules to the IPLookup table, use `IPLookup.add()`
//
// __Input Gates__: 1
// __Output Gates__: many (configurable, depending on rule values)
type IPLookupArg struct {
	MaxRules uint32 `protobuf:"varint,1,opt,name=max_rules,json=maxRules" json:"max_rules,omitempty"`
	MaxTbl8S uint32 `protobuf:"varint,2,opt,name=max_tbl8s,json=maxTbl8s" json:"max_tbl8s,omitempty"`
}

func (m *IPLookupArg) Reset()                    { *m = IPLookupArg{} }
func (m *IPLookupArg) String() string            { return proto.CompactTextString(m) }
func (*IPLookupArg) ProtoMessage()               {}
func (*IPLookupArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{49} }

func (m *IPLookupArg) GetMaxRules() uint32 {
	if m != nil {
		return m.MaxRules
	}
	return 0
}

func (m *IPLookupArg) GetMaxTbl8S() uint32 {
	if m != nil {
		return m.MaxTbl8S
	}
	return 0
}

// *
// An L2Forward module forwards packets to an output gate according to exact-match rules over
// an Ethernet destination.
// Note that this is _not_ a learning switch -- forwards according to fixed
// routes specified by `add(..)`.
//
// __Input Gates__: 1
// __Ouput Gates__: many (configurable, depending on rules)
type L2ForwardArg struct {
	Size   int64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Bucket int64 `protobuf:"varint,2,opt,name=bucket" json:"bucket,omitempty"`
	Learn  bool  `protobuf:"varint,3,opt,name=learn" json:"learn,omitempty"`
}

func (m *L2ForwardArg) Reset()                    { *m = L2ForwardArg{} }
func (m *L2ForwardArg) String() string            { return proto.CompactTextString(m) }
func (*L2ForwardArg) ProtoMessage()               {}
func (*L2ForwardArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{50} }

func (m *L2ForwardArg) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *L2ForwardArg) GetBucket() int64 {
	if m != nil {
		return m.Bucket
	}
	return 0
}

func (m *L2ForwardArg) GetLearn() bool {
	if m != nil {
		return m.Learn
	}
	return false
}

// *
// The MACSwap module takes no arguments. It swaps the src/destination MAC addresses
// within a packet.
//
// __Input Gates__: 1
// __Output Gates__: 1
type MACSwapArg struct {
}

func (m *MACSwapArg) Reset()                    { *m = MACSwapArg{} }
func (m *MACSwapArg) String() string            { return proto.CompactTextString(m) }
func (*MACSwapArg) ProtoMessage()               {}
func (*MACSwapArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{51} }

// *
// The measure module tracks latencies, packets per second, and other statistics.
// It should be paired with a Timestamp module, which attaches a timestamp to packets.
// The measure module will log how long (in nanoseconds) it has been for each packet it received since it was timestamped.
// This module is somewhat experimental and undergoing various changes.
// There is a test for the the Measure module in [`bessctl/module_tests/timestamp.py`](https://github.com/NetSys/bess/blob/master/bessctl/module_tests/timestamp.py).
//
// __Input Gates__: 1
// __Output Gates__: 1
type MeasureArg struct {
	// int64 warmup = 1; /// removed: instead of warmup delay, user should Clear()
	Offset              uint64  `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	JitterSampleProb    float64 `protobuf:"fixed64,3,opt,name=jitter_sample_prob,json=jitterSampleProb" json:"jitter_sample_prob,omitempty"`
	LatencyNsMax        uint64  `protobuf:"varint,4,opt,name=latency_ns_max,json=latencyNsMax" json:"latency_ns_max,omitempty"`
	LatencyNsResolution uint32  `protobuf:"varint,5,opt,name=latency_ns_resolution,json=latencyNsResolution" json:"latency_ns_resolution,omitempty"`
}

func (m *MeasureArg) Reset()                    { *m = MeasureArg{} }
func (m *MeasureArg) String() string            { return proto.CompactTextString(m) }
func (*MeasureArg) ProtoMessage()               {}
func (*MeasureArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{52} }

func (m *MeasureArg) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MeasureArg) GetJitterSampleProb() float64 {
	if m != nil {
		return m.JitterSampleProb
	}
	return 0
}

func (m *MeasureArg) GetLatencyNsMax() uint64 {
	if m != nil {
		return m.LatencyNsMax
	}
	return 0
}

func (m *MeasureArg) GetLatencyNsResolution() uint32 {
	if m != nil {
		return m.LatencyNsResolution
	}
	return 0
}

// *
// The merge module takes no parameters. It has multiple input gates,
// and passes out all packets from a single output gate.
//
// __Input Gates__: many (configurable)
// __Output Gates__: 1
type MergeArg struct {
}

func (m *MergeArg) Reset()                    { *m = MergeArg{} }
func (m *MergeArg) String() string            { return proto.CompactTextString(m) }
func (*MergeArg) ProtoMessage()               {}
func (*MergeArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{53} }

// *
// The MetadataTest module is used for internal testing purposes.
type MetadataTestArg struct {
	Read   map[string]int64 `protobuf:"bytes,1,rep,name=read" json:"read,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Write  map[string]int64 `protobuf:"bytes,2,rep,name=write" json:"write,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Update map[string]int64 `protobuf:"bytes,3,rep,name=update" json:"update,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *MetadataTestArg) Reset()                    { *m = MetadataTestArg{} }
func (m *MetadataTestArg) String() string            { return proto.CompactTextString(m) }
func (*MetadataTestArg) ProtoMessage()               {}
func (*MetadataTestArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{54} }

func (m *MetadataTestArg) GetRead() map[string]int64 {
	if m != nil {
		return m.Read
	}
	return nil
}

func (m *MetadataTestArg) GetWrite() map[string]int64 {
	if m != nil {
		return m.Write
	}
	return nil
}

func (m *MetadataTestArg) GetUpdate() map[string]int64 {
	if m != nil {
		return m.Update
	}
	return nil
}

// *
// The NAT module implements Dynamic IPv4 address/port translation,
// rewriting packet source addresses with external addresses as specified,
// and destination addresses for packets on the reverse direction.
// L3/L4 checksums are updated correspondingly.
// To see an example of NAT in use, see:
// [`bess/bessctl/conf/samples/nat.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/nat.bess)
//
// Currently only supports TCP/UDP/ICMP.
// Note that address/port in packet payload (e.g., FTP) are NOT translated.
//
// __Input Gates__: 2 (0 for internal->external, and 1 for external->internal direction)
// __Output Gates__: 2 (same as the input gate)
type NATArg struct {
	ExtAddrs []*NATArg_ExternalAddress `protobuf:"bytes,1,rep,name=ext_addrs,json=extAddrs" json:"ext_addrs,omitempty"`
}

func (m *NATArg) Reset()                    { *m = NATArg{} }
func (m *NATArg) String() string            { return proto.CompactTextString(m) }
func (*NATArg) ProtoMessage()               {}
func (*NATArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{55} }

func (m *NATArg) GetExtAddrs() []*NATArg_ExternalAddress {
	if m != nil {
		return m.ExtAddrs
	}
	return nil
}

type NATArg_PortRange struct {
	Begin     uint32 `protobuf:"varint,1,opt,name=begin" json:"begin,omitempty"`
	End       uint32 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	Suspended bool   `protobuf:"varint,3,opt,name=suspended" json:"suspended,omitempty"`
}

func (m *NATArg_PortRange) Reset()                    { *m = NATArg_PortRange{} }
func (m *NATArg_PortRange) String() string            { return proto.CompactTextString(m) }
func (*NATArg_PortRange) ProtoMessage()               {}
func (*NATArg_PortRange) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{55, 0} }

func (m *NATArg_PortRange) GetBegin() uint32 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *NATArg_PortRange) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *NATArg_PortRange) GetSuspended() bool {
	if m != nil {
		return m.Suspended
	}
	return false
}

type NATArg_ExternalAddress struct {
	ExtAddr    string              `protobuf:"bytes,1,opt,name=ext_addr,json=extAddr" json:"ext_addr,omitempty"`
	PortRanges []*NATArg_PortRange `protobuf:"bytes,2,rep,name=port_ranges,json=portRanges" json:"port_ranges,omitempty"`
}

func (m *NATArg_ExternalAddress) Reset()                    { *m = NATArg_ExternalAddress{} }
func (m *NATArg_ExternalAddress) String() string            { return proto.CompactTextString(m) }
func (*NATArg_ExternalAddress) ProtoMessage()               {}
func (*NATArg_ExternalAddress) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{55, 1} }

func (m *NATArg_ExternalAddress) GetExtAddr() string {
	if m != nil {
		return m.ExtAddr
	}
	return ""
}

func (m *NATArg_ExternalAddress) GetPortRanges() []*NATArg_PortRange {
	if m != nil {
		return m.PortRanges
	}
	return nil
}

// *
// Static NAT module implements one-to-one translation of source/destination
// IPv4 addresses. No port number is translated.
// L3/L4 checksums are updated correspondingly.
// To see an example of NAT in use, see:
// [`bess/bessctl/conf/samples/nat.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/nat.bess)
//
// Forward direction (from input gate 0 to output gate 0):
//  - Source IP address is updated, from internal to external address.
// Reverse direction (from input gate 1 to output gate 1):
//  - Destination IP address is updated, from external to internal address.
// If the original address is outside any of the ranges, packets are forwarded
// without NAT.
//
// Note that address in packet payload (e.g., FTP) are NOT translated.
//
// __Input Gates__: 2 (0 for internal->external, and 1 for external->internal direction)
// __Output Gates__: 2 (same as the input gate)
type StaticNATArg struct {
	Pairs []*StaticNATArg_AddressRangePair `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *StaticNATArg) Reset()                    { *m = StaticNATArg{} }
func (m *StaticNATArg) String() string            { return proto.CompactTextString(m) }
func (*StaticNATArg) ProtoMessage()               {}
func (*StaticNATArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{56} }

func (m *StaticNATArg) GetPairs() []*StaticNATArg_AddressRangePair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type StaticNATArg_AddressRange struct {
	Start string `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   string `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *StaticNATArg_AddressRange) Reset()                    { *m = StaticNATArg_AddressRange{} }
func (m *StaticNATArg_AddressRange) String() string            { return proto.CompactTextString(m) }
func (*StaticNATArg_AddressRange) ProtoMessage()               {}
func (*StaticNATArg_AddressRange) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{56, 0} }

func (m *StaticNATArg_AddressRange) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *StaticNATArg_AddressRange) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

type StaticNATArg_AddressRangePair struct {
	IntRange *StaticNATArg_AddressRange `protobuf:"bytes,1,opt,name=int_range,json=intRange" json:"int_range,omitempty"`
	ExtRange *StaticNATArg_AddressRange `protobuf:"bytes,2,opt,name=ext_range,json=extRange" json:"ext_range,omitempty"`
}

func (m *StaticNATArg_AddressRangePair) Reset()         { *m = StaticNATArg_AddressRangePair{} }
func (m *StaticNATArg_AddressRangePair) String() string { return proto.CompactTextString(m) }
func (*StaticNATArg_AddressRangePair) ProtoMessage()    {}
func (*StaticNATArg_AddressRangePair) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{56, 1}
}

func (m *StaticNATArg_AddressRangePair) GetIntRange() *StaticNATArg_AddressRange {
	if m != nil {
		return m.IntRange
	}
	return nil
}

func (m *StaticNATArg_AddressRangePair) GetExtRange() *StaticNATArg_AddressRange {
	if m != nil {
		return m.ExtRange
	}
	return nil
}

// *
// This module is used for testing purposes.
type NoOpArg struct {
}

func (m *NoOpArg) Reset()                    { *m = NoOpArg{} }
func (m *NoOpArg) String() string            { return proto.CompactTextString(m) }
func (*NoOpArg) ProtoMessage()               {}
func (*NoOpArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{57} }

// *
// The PortInc module connects a physical or virtual port and releases
// packets from it. PortInc does not support multiqueueing.
// For details on how to configure PortInc using DPDK, virtual ports,
// or libpcap, see the sidebar in the wiki.
//
// __Input Gates__: 0
// __Output Gates__: 1
type PortIncArg struct {
	Port     string `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	Prefetch bool   `protobuf:"varint,2,opt,name=prefetch" json:"prefetch,omitempty"`
}

func (m *PortIncArg) Reset()                    { *m = PortIncArg{} }
func (m *PortIncArg) String() string            { return proto.CompactTextString(m) }
func (*PortIncArg) ProtoMessage()               {}
func (*PortIncArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{58} }

func (m *PortIncArg) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *PortIncArg) GetPrefetch() bool {
	if m != nil {
		return m.Prefetch
	}
	return false
}

// *
// The PortOut module connects to a physical or virtual port and pushes
// packets to it. For details on how to configure PortOut with DPDK,
// virtual ports, libpcap, etc, see the sidebar in the wiki.
//
// __Input Gates__: 1
// __Output Gates__: 0
type PortOutArg struct {
	Port string `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
}

func (m *PortOutArg) Reset()                    { *m = PortOutArg{} }
func (m *PortOutArg) String() string            { return proto.CompactTextString(m) }
func (*PortOutArg) ProtoMessage()               {}
func (*PortOutArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{59} }

func (m *PortOutArg) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

// *
// The module QueueInc produces input packets from a physical or virtual port.
// Unlike PortInc, it supports multiqueue ports.
// For details on how to configure QueueInc with DPDK, virtualports,
// libpcap, etc, see the sidebar in the wiki.
//
// __Input Gates__: 0
// __Output Gates__: 1
type QueueIncArg struct {
	Port     string `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	Qid      uint64 `protobuf:"varint,2,opt,name=qid" json:"qid,omitempty"`
	Prefetch bool   `protobuf:"varint,3,opt,name=prefetch" json:"prefetch,omitempty"`
}

func (m *QueueIncArg) Reset()                    { *m = QueueIncArg{} }
func (m *QueueIncArg) String() string            { return proto.CompactTextString(m) }
func (*QueueIncArg) ProtoMessage()               {}
func (*QueueIncArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{60} }

func (m *QueueIncArg) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *QueueIncArg) GetQid() uint64 {
	if m != nil {
		return m.Qid
	}
	return 0
}

func (m *QueueIncArg) GetPrefetch() bool {
	if m != nil {
		return m.Prefetch
	}
	return false
}

// *
// The QueueOut module releases packets to a physical or virtual port.
// Unlike PortOut, it supports multiqueue ports.
// For details on how to configure QueueOut with DPDK, virtualports,
// libpcap, etc, see the sidebar in the wiki.
//
// __Input Gates__: 1
// __Output Gates__: 0
type QueueOutArg struct {
	Port string `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	Qid  uint64 `protobuf:"varint,2,opt,name=qid" json:"qid,omitempty"`
}

func (m *QueueOutArg) Reset()                    { *m = QueueOutArg{} }
func (m *QueueOutArg) String() string            { return proto.CompactTextString(m) }
func (*QueueOutArg) ProtoMessage()               {}
func (*QueueOutArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{61} }

func (m *QueueOutArg) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *QueueOutArg) GetQid() uint64 {
	if m != nil {
		return m.Qid
	}
	return 0
}

// *
// The Queue module implements a simple packet queue.
//
// __Input Gates__: 1
// __Output Gates__: 1
type QueueArg struct {
	Size         uint64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Prefetch     bool   `protobuf:"varint,2,opt,name=prefetch" json:"prefetch,omitempty"`
	Backpressure bool   `protobuf:"varint,3,opt,name=backpressure" json:"backpressure,omitempty"`
}

func (m *QueueArg) Reset()                    { *m = QueueArg{} }
func (m *QueueArg) String() string            { return proto.CompactTextString(m) }
func (*QueueArg) ProtoMessage()               {}
func (*QueueArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{62} }

func (m *QueueArg) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *QueueArg) GetPrefetch() bool {
	if m != nil {
		return m.Prefetch
	}
	return false
}

func (m *QueueArg) GetBackpressure() bool {
	if m != nil {
		return m.Backpressure
	}
	return false
}

// *
// The RandomSplit module randomly split/drop packets
//
// __InputGates__: 1
// __Output Gates__: many (configurable)
type RandomSplitArg struct {
	DropRate float64 `protobuf:"fixed64,1,opt,name=drop_rate,json=dropRate" json:"drop_rate,omitempty"`
	Gates    []int64 `protobuf:"varint,2,rep,packed,name=gates" json:"gates,omitempty"`
}

func (m *RandomSplitArg) Reset()                    { *m = RandomSplitArg{} }
func (m *RandomSplitArg) String() string            { return proto.CompactTextString(m) }
func (*RandomSplitArg) ProtoMessage()               {}
func (*RandomSplitArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{63} }

func (m *RandomSplitArg) GetDropRate() float64 {
	if m != nil {
		return m.DropRate
	}
	return 0
}

func (m *RandomSplitArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

// *
// The RandomSplit module has a function `set_droprate(...)` which specifies
// the probability of dropping packets
type RandomSplitCommandSetDroprateArg struct {
	DropRate float64 `protobuf:"fixed64,1,opt,name=drop_rate,json=dropRate" json:"drop_rate,omitempty"`
}

func (m *RandomSplitCommandSetDroprateArg) Reset()         { *m = RandomSplitCommandSetDroprateArg{} }
func (m *RandomSplitCommandSetDroprateArg) String() string { return proto.CompactTextString(m) }
func (*RandomSplitCommandSetDroprateArg) ProtoMessage()    {}
func (*RandomSplitCommandSetDroprateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{64}
}

func (m *RandomSplitCommandSetDroprateArg) GetDropRate() float64 {
	if m != nil {
		return m.DropRate
	}
	return 0
}

// *
// The RandomSplit module has a function `set_gates(...)` which changes
// the total number of output gates in the module.
type RandomSplitCommandSetGatesArg struct {
	Gates []int64 `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
}

func (m *RandomSplitCommandSetGatesArg) Reset()                    { *m = RandomSplitCommandSetGatesArg{} }
func (m *RandomSplitCommandSetGatesArg) String() string            { return proto.CompactTextString(m) }
func (*RandomSplitCommandSetGatesArg) ProtoMessage()               {}
func (*RandomSplitCommandSetGatesArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{65} }

func (m *RandomSplitCommandSetGatesArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

// *
// The RandomUpdate module rewrites a specified field (`offset` and `size`) in a packet
// with a random value between a specified min and max values.
//
// __Input Gates__: 1
// __Output Gates__: 1
type RandomUpdateArg struct {
	Fields []*RandomUpdateArg_Field `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
}

func (m *RandomUpdateArg) Reset()                    { *m = RandomUpdateArg{} }
func (m *RandomUpdateArg) String() string            { return proto.CompactTextString(m) }
func (*RandomUpdateArg) ProtoMessage()               {}
func (*RandomUpdateArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{66} }

func (m *RandomUpdateArg) GetFields() []*RandomUpdateArg_Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// RandomUpdate's Field specifies where to rewrite, and what values to rewrite
// in each packet processed.
type RandomUpdateArg_Field struct {
	Offset int64  `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Size   uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	Min    uint64 `protobuf:"varint,3,opt,name=min" json:"min,omitempty"`
	Max    uint64 `protobuf:"varint,4,opt,name=max" json:"max,omitempty"`
}

func (m *RandomUpdateArg_Field) Reset()                    { *m = RandomUpdateArg_Field{} }
func (m *RandomUpdateArg_Field) String() string            { return proto.CompactTextString(m) }
func (*RandomUpdateArg_Field) ProtoMessage()               {}
func (*RandomUpdateArg_Field) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{66, 0} }

func (m *RandomUpdateArg_Field) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *RandomUpdateArg_Field) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *RandomUpdateArg_Field) GetMin() uint64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *RandomUpdateArg_Field) GetMax() uint64 {
	if m != nil {
		return m.Max
	}
	return 0
}

// *
// The Rewrite module replaces an entire packet body with a packet "template"
// converting all packets that pass through to copies of the of one of
// the templates.
//
// __Input Gates__: 1
// __Output Gates__: 1
type RewriteArg struct {
	Templates [][]byte `protobuf:"bytes,1,rep,name=templates,proto3" json:"templates,omitempty"`
}

func (m *RewriteArg) Reset()                    { *m = RewriteArg{} }
func (m *RewriteArg) String() string            { return proto.CompactTextString(m) }
func (*RewriteArg) ProtoMessage()               {}
func (*RewriteArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{67} }

func (m *RewriteArg) GetTemplates() [][]byte {
	if m != nil {
		return m.Templates
	}
	return nil
}

// *
// The RoundRobin module has a function `set_gates(...)` which changes
// the total number of output gates in the module.
type RoundRobinCommandSetGatesArg struct {
	Gates []int64 `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
}

func (m *RoundRobinCommandSetGatesArg) Reset()                    { *m = RoundRobinCommandSetGatesArg{} }
func (m *RoundRobinCommandSetGatesArg) String() string            { return proto.CompactTextString(m) }
func (*RoundRobinCommandSetGatesArg) ProtoMessage()               {}
func (*RoundRobinCommandSetGatesArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{68} }

func (m *RoundRobinCommandSetGatesArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

// *
// The RoundRobin module has a function `set_mode(...)` which specifies whether
// to balance traffic across gates per-packet or per-batch.
type RoundRobinCommandSetModeArg struct {
	Mode string `protobuf:"bytes,1,opt,name=mode" json:"mode,omitempty"`
}

func (m *RoundRobinCommandSetModeArg) Reset()                    { *m = RoundRobinCommandSetModeArg{} }
func (m *RoundRobinCommandSetModeArg) String() string            { return proto.CompactTextString(m) }
func (*RoundRobinCommandSetModeArg) ProtoMessage()               {}
func (*RoundRobinCommandSetModeArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{69} }

func (m *RoundRobinCommandSetModeArg) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

// *
// The RoundRobin module splits packets from one input gate across multiple output
// gates.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type RoundRobinArg struct {
	Gates []int64 `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
	Mode  string  `protobuf:"bytes,2,opt,name=mode" json:"mode,omitempty"`
}

func (m *RoundRobinArg) Reset()                    { *m = RoundRobinArg{} }
func (m *RoundRobinArg) String() string            { return proto.CompactTextString(m) }
func (*RoundRobinArg) ProtoMessage()               {}
func (*RoundRobinArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{70} }

func (m *RoundRobinArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

func (m *RoundRobinArg) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

// *
// The Replicate module makes copies of a packet sending one copy out over each
// of n output gates.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type ReplicateArg struct {
	Gates []int64 `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
}

func (m *ReplicateArg) Reset()                    { *m = ReplicateArg{} }
func (m *ReplicateArg) String() string            { return proto.CompactTextString(m) }
func (*ReplicateArg) ProtoMessage()               {}
func (*ReplicateArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{71} }

func (m *ReplicateArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

// *
// The Replicate module has a function `set_gates(...)` which changes
// the total number of output gates in the module.
type ReplicateCommandSetGatesArg struct {
	Gates []int64 `protobuf:"varint,1,rep,packed,name=gates" json:"gates,omitempty"`
}

func (m *ReplicateCommandSetGatesArg) Reset()                    { *m = ReplicateCommandSetGatesArg{} }
func (m *ReplicateCommandSetGatesArg) String() string            { return proto.CompactTextString(m) }
func (*ReplicateCommandSetGatesArg) ProtoMessage()               {}
func (*ReplicateCommandSetGatesArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{72} }

func (m *ReplicateCommandSetGatesArg) GetGates() []int64 {
	if m != nil {
		return m.Gates
	}
	return nil
}

// *
// The SetMetadata module adds metadata attributes to packets, which are not stored
// or sent out with packet data. For examples of SetMetadata use, see
// [`bess/bessctl/conf/attr_match.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/metadata/attr_match.bess)
//
// __Input Gates__: 1
// __Output Gates__: 1
type SetMetadataArg struct {
	Attrs []*SetMetadataArg_Attribute `protobuf:"bytes,1,rep,name=attrs" json:"attrs,omitempty"`
}

func (m *SetMetadataArg) Reset()                    { *m = SetMetadataArg{} }
func (m *SetMetadataArg) String() string            { return proto.CompactTextString(m) }
func (*SetMetadataArg) ProtoMessage()               {}
func (*SetMetadataArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{73} }

func (m *SetMetadataArg) GetAttrs() []*SetMetadataArg_Attribute {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// *
// SetMetadata Attribute describes a metadata attribute and value to attach to every packet.
// If copying data from a packet buffer, SetMetadata can also logically shift
// then mask the value before storing it as metadata, i.e.,
// metadata_value = (packet_value >> `rshift_bits`) & `mask`.
type SetMetadataArg_Attribute struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Size uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*SetMetadataArg_Attribute_ValueInt
	//	*SetMetadataArg_Attribute_ValueBin
	Value      isSetMetadataArg_Attribute_Value `protobuf_oneof:"value"`
	Offset     int32                            `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
	Mask       []byte                           `protobuf:"bytes,6,opt,name=mask,proto3" json:"mask,omitempty"`
	RshiftBits int32                            `protobuf:"varint,7,opt,name=rshift_bits,json=rshiftBits" json:"rshift_bits,omitempty"`
}

func (m *SetMetadataArg_Attribute) Reset()                    { *m = SetMetadataArg_Attribute{} }
func (m *SetMetadataArg_Attribute) String() string            { return proto.CompactTextString(m) }
func (*SetMetadataArg_Attribute) ProtoMessage()               {}
func (*SetMetadataArg_Attribute) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{73, 0} }

type isSetMetadataArg_Attribute_Value interface{ isSetMetadataArg_Attribute_Value() }

type SetMetadataArg_Attribute_ValueInt struct {
	ValueInt uint64 `protobuf:"varint,3,opt,name=value_int,json=valueInt,oneof"`
}
type SetMetadataArg_Attribute_ValueBin struct {
	ValueBin []byte `protobuf:"bytes,4,opt,name=value_bin,json=valueBin,proto3,oneof"`
}

func (*SetMetadataArg_Attribute_ValueInt) isSetMetadataArg_Attribute_Value() {}
func (*SetMetadataArg_Attribute_ValueBin) isSetMetadataArg_Attribute_Value() {}

func (m *SetMetadataArg_Attribute) GetValue() isSetMetadataArg_Attribute_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetMetadataArg_Attribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetMetadataArg_Attribute) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *SetMetadataArg_Attribute) GetValueInt() uint64 {
	if x, ok := m.GetValue().(*SetMetadataArg_Attribute_ValueInt); ok {
		return x.ValueInt
	}
	return 0
}

func (m *SetMetadataArg_Attribute) GetValueBin() []byte {
	if x, ok := m.GetValue().(*SetMetadataArg_Attribute_ValueBin); ok {
		return x.ValueBin
	}
	return nil
}

func (m *SetMetadataArg_Attribute) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SetMetadataArg_Attribute) GetMask() []byte {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *SetMetadataArg_Attribute) GetRshiftBits() int32 {
	if m != nil {
		return m.RshiftBits
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SetMetadataArg_Attribute) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SetMetadataArg_Attribute_OneofMarshaler, _SetMetadataArg_Attribute_OneofUnmarshaler, _SetMetadataArg_Attribute_OneofSizer, []interface{}{
		(*SetMetadataArg_Attribute_ValueInt)(nil),
		(*SetMetadataArg_Attribute_ValueBin)(nil),
	}
}

func _SetMetadataArg_Attribute_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SetMetadataArg_Attribute)
	// value
	switch x := m.Value.(type) {
	case *SetMetadataArg_Attribute_ValueInt:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ValueInt))
	case *SetMetadataArg_Attribute_ValueBin:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ValueBin)
	case nil:
	default:
		return fmt.Errorf("SetMetadataArg_Attribute.Value has unexpected type %T", x)
	}
	return nil
}

func _SetMetadataArg_Attribute_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SetMetadataArg_Attribute)
	switch tag {
	case 3: // value.value_int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &SetMetadataArg_Attribute_ValueInt{x}
		return true, err
	case 4: // value.value_bin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Value = &SetMetadataArg_Attribute_ValueBin{x}
		return true, err
	default:
		return false, nil
	}
}

func _SetMetadataArg_Attribute_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SetMetadataArg_Attribute)
	// value
	switch x := m.Value.(type) {
	case *SetMetadataArg_Attribute_ValueInt:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ValueInt))
	case *SetMetadataArg_Attribute_ValueBin:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ValueBin)))
		n += len(x.ValueBin)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// The sink module drops all packets that are sent to it.
//
// __Input Gates__: 1
// __Output Gates__: 0
type SinkArg struct {
}

func (m *SinkArg) Reset()                    { *m = SinkArg{} }
func (m *SinkArg) String() string            { return proto.CompactTextString(m) }
func (*SinkArg) ProtoMessage()               {}
func (*SinkArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{74} }

// *
// The Source module has a function `set_burst(...)` which
// specifies the maximum number of packets to release in a single packetbatch
// from the module.
type SourceCommandSetBurstArg struct {
	Burst uint64 `protobuf:"varint,1,opt,name=burst" json:"burst,omitempty"`
}

func (m *SourceCommandSetBurstArg) Reset()                    { *m = SourceCommandSetBurstArg{} }
func (m *SourceCommandSetBurstArg) String() string            { return proto.CompactTextString(m) }
func (*SourceCommandSetBurstArg) ProtoMessage()               {}
func (*SourceCommandSetBurstArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{75} }

func (m *SourceCommandSetBurstArg) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

// *
// The Source module has a function `set_pkt_size(...)` which specifies the size
// of packets to be produced by the Source module.
type SourceCommandSetPktSizeArg struct {
	PktSize uint64 `protobuf:"varint,1,opt,name=pkt_size,json=pktSize" json:"pkt_size,omitempty"`
}

func (m *SourceCommandSetPktSizeArg) Reset()                    { *m = SourceCommandSetPktSizeArg{} }
func (m *SourceCommandSetPktSizeArg) String() string            { return proto.CompactTextString(m) }
func (*SourceCommandSetPktSizeArg) ProtoMessage()               {}
func (*SourceCommandSetPktSizeArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{76} }

func (m *SourceCommandSetPktSizeArg) GetPktSize() uint64 {
	if m != nil {
		return m.PktSize
	}
	return 0
}

// *
// The Source module generates packets with no payload contents.
//
// __Input Gates__: 0
// __Output Gates__: 1
type SourceArg struct {
	PktSize uint64 `protobuf:"varint,1,opt,name=pkt_size,json=pktSize" json:"pkt_size,omitempty"`
}

func (m *SourceArg) Reset()                    { *m = SourceArg{} }
func (m *SourceArg) String() string            { return proto.CompactTextString(m) }
func (*SourceArg) ProtoMessage()               {}
func (*SourceArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{77} }

func (m *SourceArg) GetPktSize() uint64 {
	if m != nil {
		return m.PktSize
	}
	return 0
}

// *
// The Split module is a basic classifier which directs packets out a gate
// based on data in the packet (e.g., if the read in value is 3, the packet
// is directed out output gate 3).
//
// __Input Gates__: 1
// __Output Gates__: many (up to 2^(size * 8))
type SplitArg struct {
	Size uint64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*SplitArg_Attribute
	//	*SplitArg_Offset
	Type isSplitArg_Type `protobuf_oneof:"type"`
}

func (m *SplitArg) Reset()                    { *m = SplitArg{} }
func (m *SplitArg) String() string            { return proto.CompactTextString(m) }
func (*SplitArg) ProtoMessage()               {}
func (*SplitArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{78} }

type isSplitArg_Type interface{ isSplitArg_Type() }

type SplitArg_Attribute struct {
	Attribute string `protobuf:"bytes,2,opt,name=attribute,oneof"`
}
type SplitArg_Offset struct {
	Offset int64 `protobuf:"varint,3,opt,name=offset,oneof"`
}

func (*SplitArg_Attribute) isSplitArg_Type() {}
func (*SplitArg_Offset) isSplitArg_Type()    {}

func (m *SplitArg) GetType() isSplitArg_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *SplitArg) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *SplitArg) GetAttribute() string {
	if x, ok := m.GetType().(*SplitArg_Attribute); ok {
		return x.Attribute
	}
	return ""
}

func (m *SplitArg) GetOffset() int64 {
	if x, ok := m.GetType().(*SplitArg_Offset); ok {
		return x.Offset
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SplitArg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SplitArg_OneofMarshaler, _SplitArg_OneofUnmarshaler, _SplitArg_OneofSizer, []interface{}{
		(*SplitArg_Attribute)(nil),
		(*SplitArg_Offset)(nil),
	}
}

func _SplitArg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SplitArg)
	// type
	switch x := m.Type.(type) {
	case *SplitArg_Attribute:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Attribute)
	case *SplitArg_Offset:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Offset))
	case nil:
	default:
		return fmt.Errorf("SplitArg.Type has unexpected type %T", x)
	}
	return nil
}

func _SplitArg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SplitArg)
	switch tag {
	case 2: // type.attribute
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &SplitArg_Attribute{x}
		return true, err
	case 3: // type.offset
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &SplitArg_Offset{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _SplitArg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SplitArg)
	// type
	switch x := m.Type.(type) {
	case *SplitArg_Attribute:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Attribute)))
		n += len(x.Attribute)
	case *SplitArg_Offset:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Offset))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// The timestamp module takes an offset parameter. It inserts the current
// time in nanoseconds into the packet, to be used for latency measurements
// alongside the Measure module.  The default offset is after an IPv4 UDP
// header.
//
// __Input Gates__: 1
// __Output Gates__: 1
type TimestampArg struct {
	Offset uint64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
}

func (m *TimestampArg) Reset()                    { *m = TimestampArg{} }
func (m *TimestampArg) String() string            { return proto.CompactTextString(m) }
func (*TimestampArg) ProtoMessage()               {}
func (*TimestampArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{79} }

func (m *TimestampArg) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// *
// The Update module rewrites a field in a packet's data with a specific value.
//
// __Input Gates__: 1
// __Output Gates__: 1
type UpdateArg struct {
	Fields []*UpdateArg_Field `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
}

func (m *UpdateArg) Reset()                    { *m = UpdateArg{} }
func (m *UpdateArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateArg) ProtoMessage()               {}
func (*UpdateArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{80} }

func (m *UpdateArg) GetFields() []*UpdateArg_Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// Update Field describes where in a packet's data to rewrite, and with what value.
type UpdateArg_Field struct {
	Offset int64  `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Size   uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	Value  uint64 `protobuf:"varint,3,opt,name=value" json:"value,omitempty"`
}

func (m *UpdateArg_Field) Reset()                    { *m = UpdateArg_Field{} }
func (m *UpdateArg_Field) String() string            { return proto.CompactTextString(m) }
func (*UpdateArg_Field) ProtoMessage()               {}
func (*UpdateArg_Field) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{80, 0} }

func (m *UpdateArg_Field) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *UpdateArg_Field) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *UpdateArg_Field) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// *
// The URLFilter performs TCP reconstruction over a flow and blocks
// connections which mention a banned URL.
//
// __Input Gates__: 2
// __Output Gates__: 2
//
// Note that the add() command takes this same argument, and the
// clear() command takes an empty argument.
type UrlFilterArg struct {
	Blacklist []*UrlFilterArg_Url `protobuf:"bytes,1,rep,name=blacklist" json:"blacklist,omitempty"`
}

func (m *UrlFilterArg) Reset()                    { *m = UrlFilterArg{} }
func (m *UrlFilterArg) String() string            { return proto.CompactTextString(m) }
func (*UrlFilterArg) ProtoMessage()               {}
func (*UrlFilterArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{81} }

func (m *UrlFilterArg) GetBlacklist() []*UrlFilterArg_Url {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

// *
// A URL consists of a host and a path.
type UrlFilterArg_Url struct {
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *UrlFilterArg_Url) Reset()                    { *m = UrlFilterArg_Url{} }
func (m *UrlFilterArg_Url) String() string            { return proto.CompactTextString(m) }
func (*UrlFilterArg_Url) ProtoMessage()               {}
func (*UrlFilterArg_Url) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{81, 0} }

func (m *UrlFilterArg_Url) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *UrlFilterArg_Url) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// *
// The runtime configuration of a URLFilter is the current
// blacklist.  This means that getting the Arg gets an *empty*
// list: we assume anyone using get_initial_arg is also using
// get_runtime_config.
type UrlFilterConfig struct {
	Blacklist []*UrlFilterArg_Url `protobuf:"bytes,1,rep,name=blacklist" json:"blacklist,omitempty"`
}

func (m *UrlFilterConfig) Reset()                    { *m = UrlFilterConfig{} }
func (m *UrlFilterConfig) String() string            { return proto.CompactTextString(m) }
func (*UrlFilterConfig) ProtoMessage()               {}
func (*UrlFilterConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{82} }

func (m *UrlFilterConfig) GetBlacklist() []*UrlFilterArg_Url {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

// *
// VLANPop removes the VLAN tag.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VLANPopArg struct {
}

func (m *VLANPopArg) Reset()                    { *m = VLANPopArg{} }
func (m *VLANPopArg) String() string            { return proto.CompactTextString(m) }
func (*VLANPopArg) ProtoMessage()               {}
func (*VLANPopArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{83} }

// *
// VLANPush appends a VLAN tag with a specified TCI value.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VLANPushArg struct {
	Tci uint64 `protobuf:"varint,1,opt,name=tci" json:"tci,omitempty"`
}

func (m *VLANPushArg) Reset()                    { *m = VLANPushArg{} }
func (m *VLANPushArg) String() string            { return proto.CompactTextString(m) }
func (*VLANPushArg) ProtoMessage()               {}
func (*VLANPushArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{84} }

func (m *VLANPushArg) GetTci() uint64 {
	if m != nil {
		return m.Tci
	}
	return 0
}

// *
// Splits packets across output gates according to VLAN id (e.g., id 3 goes out gate 3).
//
// __Input Gates__: 1
// __Output Gates__: many
type VLANSplitArg struct {
}

func (m *VLANSplitArg) Reset()                    { *m = VLANSplitArg{} }
func (m *VLANSplitArg) String() string            { return proto.CompactTextString(m) }
func (*VLANSplitArg) ProtoMessage()               {}
func (*VLANSplitArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{85} }

// *
// VXLANDecap module decapsulates a VXLAN header on a packet.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VXLANDecapArg struct {
}

func (m *VXLANDecapArg) Reset()                    { *m = VXLANDecapArg{} }
func (m *VXLANDecapArg) String() string            { return proto.CompactTextString(m) }
func (*VXLANDecapArg) ProtoMessage()               {}
func (*VXLANDecapArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{86} }

// *
// VXLANEncap module wraps a packet in a VXLAN header with a specified destination port.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VXLANEncapArg struct {
	Dstport uint64 `protobuf:"varint,1,opt,name=dstport" json:"dstport,omitempty"`
}

func (m *VXLANEncapArg) Reset()                    { *m = VXLANEncapArg{} }
func (m *VXLANEncapArg) String() string            { return proto.CompactTextString(m) }
func (*VXLANEncapArg) ProtoMessage()               {}
func (*VXLANEncapArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{87} }

func (m *VXLANEncapArg) GetDstport() uint64 {
	if m != nil {
		return m.Dstport
	}
	return 0
}

// *
// The WildcardMatch module matches over multiple fields in a packet and
// pushes packets that do match out a specified gate, and those that don't out a default
// gate. WildcardMatch is initialized with the fields it should inspect over,
// rules are added via the `add(...)` function.
// An example of WildcardMatch is in [`bess/bessctl/conf/samples/wildcardmatch.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/wildcardmatch.bess)
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type WildcardMatchArg struct {
	Fields []*Field `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
}

func (m *WildcardMatchArg) Reset()                    { *m = WildcardMatchArg{} }
func (m *WildcardMatchArg) String() string            { return proto.CompactTextString(m) }
func (*WildcardMatchArg) ProtoMessage()               {}
func (*WildcardMatchArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{88} }

func (m *WildcardMatchArg) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// *
// WildcardMatchConfig represents the current runtime configuration
// of a WildcardMatch module, as returned by get_runtime_config and
// set by set_runtime_config.
type WildcardMatchConfig struct {
	DefaultGate uint64                        `protobuf:"varint,1,opt,name=default_gate,json=defaultGate" json:"default_gate,omitempty"`
	Rules       []*WildcardMatchCommandAddArg `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
}

func (m *WildcardMatchConfig) Reset()                    { *m = WildcardMatchConfig{} }
func (m *WildcardMatchConfig) String() string            { return proto.CompactTextString(m) }
func (*WildcardMatchConfig) ProtoMessage()               {}
func (*WildcardMatchConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{89} }

func (m *WildcardMatchConfig) GetDefaultGate() uint64 {
	if m != nil {
		return m.DefaultGate
	}
	return 0
}

func (m *WildcardMatchConfig) GetRules() []*WildcardMatchCommandAddArg {
	if m != nil {
		return m.Rules
	}
	return nil
}

// *
// The ARP Responder module is responding to ARP requests
// TODO: Dynamic learn new MAC's-IP's mapping
//
// __Input Gates__: 1
// __Output Gates__: 1
type ArpResponderArg struct {
	// *
	// One ARP IP-MAC mapping
	Ip      string `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	MacAddr string `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
}

func (m *ArpResponderArg) Reset()                    { *m = ArpResponderArg{} }
func (m *ArpResponderArg) String() string            { return proto.CompactTextString(m) }
func (*ArpResponderArg) ProtoMessage()               {}
func (*ArpResponderArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{90} }

func (m *ArpResponderArg) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ArpResponderArg) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

// *
// The MPLS pop module removes MPLS labels
//
// __Input Gates__: 1
// __Output Gates__: 2
type MplsPopArg struct {
	RemoveEthHeader bool   `protobuf:"varint,1,opt,name=remove_eth_header,json=removeEthHeader" json:"remove_eth_header,omitempty"`
	NextEthType     uint32 `protobuf:"varint,2,opt,name=next_eth_type,json=nextEthType" json:"next_eth_type,omitempty"`
}

func (m *MplsPopArg) Reset()                    { *m = MplsPopArg{} }
func (m *MplsPopArg) String() string            { return proto.CompactTextString(m) }
func (*MplsPopArg) ProtoMessage()               {}
func (*MplsPopArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{91} }

func (m *MplsPopArg) GetRemoveEthHeader() bool {
	if m != nil {
		return m.RemoveEthHeader
	}
	return false
}

func (m *MplsPopArg) GetNextEthType() uint32 {
	if m != nil {
		return m.NextEthType
	}
	return 0
}

// *
// WorkerSplit splits packets based on the worker calling ProcessBatch(). It has
// two modes.
// 1) Packets from worker `x` are mapped to output gate `x`. This is the default
//    mode.
// 2) When the `worker_gates` field is set, packets from a worker `x` are mapped
//    to `worker_gates[x]`.  In this mode, packet batches from workers not
//    mapped to an output gate will be dropped.
//
// Calling the `reset` command with an empty `worker_gates` field will revert
// WorkerSplit to the default mode.
//
// __Input Gates__: 1
// __Output Gates__: many
type WorkerSplitArg struct {
	WorkerGates map[uint32]uint32 `protobuf:"bytes,1,rep,name=worker_gates,json=workerGates" json:"worker_gates,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *WorkerSplitArg) Reset()                    { *m = WorkerSplitArg{} }
func (m *WorkerSplitArg) String() string            { return proto.CompactTextString(m) }
func (*WorkerSplitArg) ProtoMessage()               {}
func (*WorkerSplitArg) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{92} }

func (m *WorkerSplitArg) GetWorkerGates() map[uint32]uint32 {
	if m != nil {
		return m.WorkerGates
	}
	return nil
}

func init() {
	proto.RegisterType((*EmptyArg)(nil), "bess.pb.EmptyArg")
	proto.RegisterType((*BPFCommandClearArg)(nil), "bess.pb.BPFCommandClearArg")
	proto.RegisterType((*ExactMatchCommandAddArg)(nil), "bess.pb.ExactMatchCommandAddArg")
	proto.RegisterType((*ExactMatchCommandDeleteArg)(nil), "bess.pb.ExactMatchCommandDeleteArg")
	proto.RegisterType((*ExactMatchCommandClearArg)(nil), "bess.pb.ExactMatchCommandClearArg")
	proto.RegisterType((*ExactMatchCommandSetDefaultGateArg)(nil), "bess.pb.ExactMatchCommandSetDefaultGateArg")
	proto.RegisterType((*FlowGenCommandSetBurstArg)(nil), "bess.pb.FlowGenCommandSetBurstArg")
	proto.RegisterType((*HashLBCommandSetModeArg)(nil), "bess.pb.HashLBCommandSetModeArg")
	proto.RegisterType((*HashLBCommandSetGatesArg)(nil), "bess.pb.HashLBCommandSetGatesArg")
	proto.RegisterType((*IPLookupCommandAddArg)(nil), "bess.pb.IPLookupCommandAddArg")
	proto.RegisterType((*IPLookupCommandDeleteArg)(nil), "bess.pb.IPLookupCommandDeleteArg")
	proto.RegisterType((*IPLookupCommandClearArg)(nil), "bess.pb.IPLookupCommandClearArg")
	proto.RegisterType((*L2ForwardCommandAddArg)(nil), "bess.pb.L2ForwardCommandAddArg")
	proto.RegisterType((*L2ForwardCommandAddArg_Entry)(nil), "bess.pb.L2ForwardCommandAddArg.Entry")
	proto.RegisterType((*L2ForwardCommandDeleteArg)(nil), "bess.pb.L2ForwardCommandDeleteArg")
	proto.RegisterType((*L2ForwardCommandSetDefaultGateArg)(nil), "bess.pb.L2ForwardCommandSetDefaultGateArg")
	proto.RegisterType((*L2ForwardCommandLookupArg)(nil), "bess.pb.L2ForwardCommandLookupArg")
	proto.RegisterType((*L2ForwardCommandLookupResponse)(nil), "bess.pb.L2ForwardCommandLookupResponse")
	proto.RegisterType((*L2ForwardCommandPopulateArg)(nil), "bess.pb.L2ForwardCommandPopulateArg")
	proto.RegisterType((*MeasureCommandGetSummaryArg)(nil), "bess.pb.MeasureCommandGetSummaryArg")
	proto.RegisterType((*MeasureCommandGetSummaryResponse)(nil), "bess.pb.MeasureCommandGetSummaryResponse")
	proto.RegisterType((*MeasureCommandGetSummaryResponse_Histogram)(nil), "bess.pb.MeasureCommandGetSummaryResponse.Histogram")
	proto.RegisterType((*DRRArg)(nil), "bess.pb.DRRArg")
	proto.RegisterType((*DRRQuantumArg)(nil), "bess.pb.DRRQuantumArg")
	proto.RegisterType((*DRRMaxFlowQueueSizeArg)(nil), "bess.pb.DRRMaxFlowQueueSizeArg")
	proto.RegisterType((*PortIncCommandSetBurstArg)(nil), "bess.pb.PortIncCommandSetBurstArg")
	proto.RegisterType((*QueueIncCommandSetBurstArg)(nil), "bess.pb.QueueIncCommandSetBurstArg")
	proto.RegisterType((*QueueCommandSetBurstArg)(nil), "bess.pb.QueueCommandSetBurstArg")
	proto.RegisterType((*QueueCommandSetSizeArg)(nil), "bess.pb.QueueCommandSetSizeArg")
	proto.RegisterType((*QueueCommandGetStatusArg)(nil), "bess.pb.QueueCommandGetStatusArg")
	proto.RegisterType((*QueueCommandGetStatusResponse)(nil), "bess.pb.QueueCommandGetStatusResponse")
	proto.RegisterType((*RandomUpdateCommandClearArg)(nil), "bess.pb.RandomUpdateCommandClearArg")
	proto.RegisterType((*RewriteCommandClearArg)(nil), "bess.pb.RewriteCommandClearArg")
	proto.RegisterType((*UpdateCommandClearArg)(nil), "bess.pb.UpdateCommandClearArg")
	proto.RegisterType((*WildcardMatchCommandAddArg)(nil), "bess.pb.WildcardMatchCommandAddArg")
	proto.RegisterType((*WildcardMatchCommandDeleteArg)(nil), "bess.pb.WildcardMatchCommandDeleteArg")
	proto.RegisterType((*WildcardMatchCommandClearArg)(nil), "bess.pb.WildcardMatchCommandClearArg")
	proto.RegisterType((*WildcardMatchCommandSetDefaultGateArg)(nil), "bess.pb.WildcardMatchCommandSetDefaultGateArg")
	proto.RegisterType((*ACLArg)(nil), "bess.pb.ACLArg")
	proto.RegisterType((*ACLArg_Rule)(nil), "bess.pb.ACLArg.Rule")
	proto.RegisterType((*BPFArg)(nil), "bess.pb.BPFArg")
	proto.RegisterType((*BPFArg_Filter)(nil), "bess.pb.BPFArg.Filter")
	proto.RegisterType((*BufferArg)(nil), "bess.pb.BufferArg")
	proto.RegisterType((*BypassArg)(nil), "bess.pb.BypassArg")
	proto.RegisterType((*DumpArg)(nil), "bess.pb.DumpArg")
	proto.RegisterType((*EtherEncapArg)(nil), "bess.pb.EtherEncapArg")
	proto.RegisterType((*ExactMatchArg)(nil), "bess.pb.ExactMatchArg")
	proto.RegisterType((*ExactMatchConfig)(nil), "bess.pb.ExactMatchConfig")
	proto.RegisterType((*FlowGenArg)(nil), "bess.pb.FlowGenArg")
	proto.RegisterType((*GenericDecapArg)(nil), "bess.pb.GenericDecapArg")
	proto.RegisterType((*GenericEncapArg)(nil), "bess.pb.GenericEncapArg")
	proto.RegisterType((*GenericEncapArg_EncapField)(nil), "bess.pb.GenericEncapArg.EncapField")
	proto.RegisterType((*HashLBArg)(nil), "bess.pb.HashLBArg")
	proto.RegisterType((*IPEncapArg)(nil), "bess.pb.IPEncapArg")
	proto.RegisterType((*IPLookupArg)(nil), "bess.pb.IPLookupArg")
	proto.RegisterType((*L2ForwardArg)(nil), "bess.pb.L2ForwardArg")
	proto.RegisterType((*MACSwapArg)(nil), "bess.pb.MACSwapArg")
	proto.RegisterType((*MeasureArg)(nil), "bess.pb.MeasureArg")
	proto.RegisterType((*MergeArg)(nil), "bess.pb.MergeArg")
	proto.RegisterType((*MetadataTestArg)(nil), "bess.pb.MetadataTestArg")
	proto.RegisterType((*NATArg)(nil), "bess.pb.NATArg")
	proto.RegisterType((*NATArg_PortRange)(nil), "bess.pb.NATArg.PortRange")
	proto.RegisterType((*NATArg_ExternalAddress)(nil), "bess.pb.NATArg.ExternalAddress")
	proto.RegisterType((*StaticNATArg)(nil), "bess.pb.StaticNATArg")
	proto.RegisterType((*StaticNATArg_AddressRange)(nil), "bess.pb.StaticNATArg.AddressRange")
	proto.RegisterType((*StaticNATArg_AddressRangePair)(nil), "bess.pb.StaticNATArg.AddressRangePair")
	proto.RegisterType((*NoOpArg)(nil), "bess.pb.NoOpArg")
	proto.RegisterType((*PortIncArg)(nil), "bess.pb.PortIncArg")
	proto.RegisterType((*PortOutArg)(nil), "bess.pb.PortOutArg")
	proto.RegisterType((*QueueIncArg)(nil), "bess.pb.QueueIncArg")
	proto.RegisterType((*QueueOutArg)(nil), "bess.pb.QueueOutArg")
	proto.RegisterType((*QueueArg)(nil), "bess.pb.QueueArg")
	proto.RegisterType((*RandomSplitArg)(nil), "bess.pb.RandomSplitArg")
	proto.RegisterType((*RandomSplitCommandSetDroprateArg)(nil), "bess.pb.RandomSplitCommandSetDroprateArg")
	proto.RegisterType((*RandomSplitCommandSetGatesArg)(nil), "bess.pb.RandomSplitCommandSetGatesArg")
	proto.RegisterType((*RandomUpdateArg)(nil), "bess.pb.RandomUpdateArg")
	proto.RegisterType((*RandomUpdateArg_Field)(nil), "bess.pb.RandomUpdateArg.Field")
	proto.RegisterType((*RewriteArg)(nil), "bess.pb.RewriteArg")
	proto.RegisterType((*RoundRobinCommandSetGatesArg)(nil), "bess.pb.RoundRobinCommandSetGatesArg")
	proto.RegisterType((*RoundRobinCommandSetModeArg)(nil), "bess.pb.RoundRobinCommandSetModeArg")
	proto.RegisterType((*RoundRobinArg)(nil), "bess.pb.RoundRobinArg")
	proto.RegisterType((*ReplicateArg)(nil), "bess.pb.ReplicateArg")
	proto.RegisterType((*ReplicateCommandSetGatesArg)(nil), "bess.pb.ReplicateCommandSetGatesArg")
	proto.RegisterType((*SetMetadataArg)(nil), "bess.pb.SetMetadataArg")
	proto.RegisterType((*SetMetadataArg_Attribute)(nil), "bess.pb.SetMetadataArg.Attribute")
	proto.RegisterType((*SinkArg)(nil), "bess.pb.SinkArg")
	proto.RegisterType((*SourceCommandSetBurstArg)(nil), "bess.pb.SourceCommandSetBurstArg")
	proto.RegisterType((*SourceCommandSetPktSizeArg)(nil), "bess.pb.SourceCommandSetPktSizeArg")
	proto.RegisterType((*SourceArg)(nil), "bess.pb.SourceArg")
	proto.RegisterType((*SplitArg)(nil), "bess.pb.SplitArg")
	proto.RegisterType((*TimestampArg)(nil), "bess.pb.TimestampArg")
	proto.RegisterType((*UpdateArg)(nil), "bess.pb.UpdateArg")
	proto.RegisterType((*UpdateArg_Field)(nil), "bess.pb.UpdateArg.Field")
	proto.RegisterType((*UrlFilterArg)(nil), "bess.pb.UrlFilterArg")
	proto.RegisterType((*UrlFilterArg_Url)(nil), "bess.pb.UrlFilterArg.Url")
	proto.RegisterType((*UrlFilterConfig)(nil), "bess.pb.UrlFilterConfig")
	proto.RegisterType((*VLANPopArg)(nil), "bess.pb.VLANPopArg")
	proto.RegisterType((*VLANPushArg)(nil), "bess.pb.VLANPushArg")
	proto.RegisterType((*VLANSplitArg)(nil), "bess.pb.VLANSplitArg")
	proto.RegisterType((*VXLANDecapArg)(nil), "bess.pb.VXLANDecapArg")
	proto.RegisterType((*VXLANEncapArg)(nil), "bess.pb.VXLANEncapArg")
	proto.RegisterType((*WildcardMatchArg)(nil), "bess.pb.WildcardMatchArg")
	proto.RegisterType((*WildcardMatchConfig)(nil), "bess.pb.WildcardMatchConfig")
	proto.RegisterType((*ArpResponderArg)(nil), "bess.pb.ArpResponderArg")
	proto.RegisterType((*MplsPopArg)(nil), "bess.pb.MplsPopArg")
	proto.RegisterType((*WorkerSplitArg)(nil), "bess.pb.WorkerSplitArg")
}

func init() { proto.RegisterFile("module_msg.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 2936 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x19, 0xdb, 0x72, 0x14, 0xc7,
	0x95, 0xd9, 0xfb, 0x9e, 0xdd, 0x95, 0xe4, 0x01, 0xc4, 0xb2, 0xdc, 0xe4, 0x01, 0x13, 0x4c, 0xd9,
	0x32, 0x16, 0x09, 0x17, 0x9b, 0x32, 0x25, 0x21, 0x81, 0x88, 0x91, 0xbc, 0x8c, 0xc0, 0x24, 0x55,
	0x49, 0x36, 0xbd, 0x3b, 0x2d, 0x69, 0xa2, 0xb9, 0xd1, 0xdd, 0x03, 0x92, 0x5f, 0x53, 0x95, 0x4a,
	0x52, 0x79, 0x73, 0xde, 0x5c, 0xa9, 0x4a, 0xf9, 0x39, 0xff, 0x91, 0xca, 0x17, 0xe4, 0x0b, 0xf2,
	0x9e, 0xd7, 0xbc, 0xa5, 0x4e, 0x77, 0x4f, 0xcf, 0xec, 0xb2, 0x02, 0x89, 0xb7, 0x3e, 0xf7, 0xd3,
	0xdd, 0x67, 0xce, 0xa5, 0x07, 0xe6, 0xc2, 0xd8, 0x4b, 0x03, 0x3a, 0x08, 0xf9, 0xce, 0x62, 0xc2,
	0x62, 0x11, 0xdb, 0xf5, 0x21, 0xe5, 0x7c, 0x31, 0x19, 0xf6, 0x66, 0x52, 0xe1, 0x07, 0x39, 0xc1,
	0x01, 0x68, 0xac, 0x85, 0x89, 0x38, 0x58, 0x66, 0x3b, 0xce, 0x29, 0xb0, 0x57, 0xfa, 0x0f, 0x1f,
	0xc4, 0x61, 0x48, 0x22, 0xef, 0x41, 0x40, 0x09, 0x43, 0xec, 0x2f, 0xe1, 0xcc, 0xda, 0x3e, 0x19,
	0x89, 0x0d, 0x22, 0x46, 0xbb, 0x9a, 0xb8, 0xec, 0x79, 0xcb, 0x6c, 0xc7, 0xb6, 0xa1, 0xb2, 0x43,
	0x04, 0xed, 0x5a, 0x0b, 0xd6, 0xb5, 0x8a, 0x2b, 0xd7, 0xf6, 0x75, 0xa8, 0x6d, 0xfb, 0x34, 0xf0,
	0x78, 0xb7, 0xb4, 0x50, 0xbe, 0xd6, 0x5a, 0xb2, 0x17, 0xb5, 0xe9, 0xc5, 0x87, 0x88, 0x5e, 0x25,
	0x82, 0xb8, 0x9a, 0xc3, 0x59, 0x87, 0xde, 0x1b, 0xaa, 0x57, 0x69, 0x40, 0x05, 0x45, 0xed, 0xc7,
	0xd1, 0x74, 0x0e, 0xce, 0xbe, 0xa1, 0xc9, 0xec, 0xe0, 0x0e, 0x38, 0x6f, 0x10, 0xb7, 0xa8, 0x58,
	0xa5, 0xdb, 0x24, 0x0d, 0xc4, 0x23, 0xa2, 0xcc, 0x4d, 0xd9, 0x8c, 0xf3, 0x39, 0x9c, 0x7d, 0x18,
	0xc4, 0xaf, 0x1f, 0xd1, 0x28, 0x17, 0x5b, 0x49, 0x19, 0x17, 0x28, 0x70, 0x0a, 0xaa, 0x43, 0x5c,
	0x6b, 0x09, 0x05, 0x38, 0xcf, 0xe1, 0xcc, 0x3a, 0xe1, 0xbb, 0x4f, 0x56, 0x72, 0x89, 0x8d, 0xd8,
	0xcb, 0x2c, 0x84, 0xb1, 0xa7, 0x2c, 0x34, 0x5d, 0xb9, 0xb6, 0xaf, 0x4e, 0x6c, 0x72, 0x66, 0x7c,
	0x93, 0x66, 0x83, 0x37, 0xa0, 0x3b, 0xa9, 0x16, 0x1d, 0xe7, 0xda, 0x11, 0xf4, 0x96, 0x77, 0xad,
	0x85, 0xf2, 0xb5, 0xb2, 0xab, 0x00, 0x67, 0x08, 0xa7, 0x1f, 0xf7, 0x9f, 0xc4, 0xf1, 0x5e, 0x9a,
	0x8c, 0xdf, 0xda, 0x3c, 0xd4, 0x12, 0x46, 0xb7, 0xfd, 0x7d, 0xed, 0x88, 0x86, 0xec, 0x0b, 0x00,
	0x6a, 0x35, 0x08, 0x68, 0xd4, 0x2d, 0xc9, 0x4d, 0x35, 0x15, 0xe6, 0x09, 0x8d, 0xcc, 0xf9, 0x94,
	0x0b, 0xe7, 0xf3, 0x14, 0xba, 0x13, 0x36, 0xf2, 0xeb, 0x7b, 0x3f, 0x33, 0xce, 0x59, 0x38, 0x33,
	0xa1, 0xd2, 0xdc, 0xe3, 0x9f, 0x2d, 0x98, 0x7f, 0xb2, 0xf4, 0x30, 0x66, 0xaf, 0x09, 0xf3, 0xc6,
	0xf7, 0x74, 0x1f, 0xea, 0x34, 0x12, 0xcc, 0xd7, 0x87, 0xd0, 0x5a, 0xfa, 0xc8, 0x9c, 0xe3, 0x74,
	0x89, 0xc5, 0xb5, 0x48, 0xb0, 0x03, 0x37, 0x93, 0xea, 0x7d, 0x06, 0x55, 0x89, 0xc1, 0x6d, 0x12,
	0xcf, 0x63, 0xd9, 0x25, 0xe1, 0xda, 0x6c, 0x1d, 0x9d, 0x2d, 0xe7, 0xa1, 0x31, 0xa9, 0x39, 0xdf,
	0xfb, 0x29, 0xa8, 0xa2, 0xa0, 0x72, 0xa6, 0xe9, 0x2a, 0xc0, 0xb9, 0x0d, 0x1f, 0x4e, 0x8a, 0xbc,
	0x3d, 0x0c, 0xdf, 0x62, 0x4b, 0x9d, 0xd0, 0xe1, 0xb6, 0x6e, 0xc1, 0xc5, 0xe9, 0x22, 0x2e, 0xe5,
	0x49, 0x1c, 0x71, 0x3a, 0x1e, 0x35, 0x95, 0x2c, 0x6a, 0xb6, 0xe1, 0xdc, 0xa4, 0x5c, 0x3f, 0x4e,
	0xd2, 0x20, 0xf7, 0x6e, 0x48, 0xb8, 0x09, 0x61, 0x5c, 0xa3, 0xa2, 0x51, 0x9c, 0x46, 0x42, 0x1f,
	0x8f, 0x02, 0xf0, 0x9a, 0x51, 0xe3, 0x40, 0x91, 0xca, 0x92, 0xd4, 0x44, 0xcc, 0x03, 0x44, 0x38,
	0xdf, 0x5b, 0x70, 0x6e, 0x83, 0x12, 0x9e, 0x32, 0xaa, 0xcd, 0x3c, 0xa2, 0x62, 0x2b, 0x0d, 0x43,
	0xc2, 0x0e, 0xf4, 0xae, 0x46, 0x78, 0xef, 0xd2, 0x52, 0xc3, 0x55, 0x80, 0xfd, 0x19, 0x9c, 0x44,
	0x4f, 0xa2, 0xd1, 0xc1, 0x20, 0xa1, 0x6c, 0x44, 0x23, 0xe1, 0x07, 0x54, 0x7d, 0x3a, 0x96, 0x6b,
	0x6b, 0x52, 0x3f, 0xa7, 0xd8, 0x9f, 0x82, 0xfd, 0x3b, 0x5f, 0x08, 0xca, 0xc6, 0xf8, 0xcb, 0x92,
	0xff, 0x03, 0x45, 0x29, 0xb0, 0x3b, 0x7f, 0xa8, 0xc0, 0xc2, 0x61, 0x5e, 0x99, 0x83, 0x3b, 0x0f,
	0x4d, 0xe1, 0x87, 0x94, 0x0b, 0x12, 0x26, 0xd2, 0x3d, 0xcb, 0xcd, 0x11, 0x76, 0x17, 0xea, 0x09,
	0x19, 0xed, 0x51, 0xc1, 0x75, 0x6c, 0x67, 0xa0, 0x3c, 0x3b, 0x5f, 0xf0, 0xec, 0x03, 0xc2, 0xb5,
	0xbd, 0x01, 0x75, 0xed, 0x75, 0xb7, 0xb2, 0x60, 0x5d, 0x6b, 0x2d, 0xdd, 0x34, 0x71, 0xfb, 0x2e,
	0x3f, 0x16, 0xd7, 0x7d, 0x2e, 0xe2, 0x1d, 0x46, 0x42, 0x37, 0xd3, 0x61, 0x7f, 0x0d, 0x35, 0xb5,
	0xa9, 0x6e, 0xf5, 0xfd, 0xb5, 0x69, 0x15, 0xbd, 0xff, 0x59, 0xd0, 0x34, 0xd8, 0xfc, 0x96, 0x75,
	0xb6, 0x53, 0xb7, 0x7c, 0x09, 0x5a, 0x64, 0x18, 0xbf, 0xa2, 0x03, 0x46, 0xa2, 0x1d, 0xaa, 0x77,
	0x0c, 0x12, 0xe5, 0x22, 0xc6, 0xbe, 0x0c, 0x1d, 0x46, 0x79, 0x1c, 0xa4, 0xc2, 0x8f, 0xa3, 0x41,
	0xc4, 0xbb, 0x0d, 0xc9, 0xd2, 0xce, 0x91, 0x9b, 0xdc, 0x3e, 0x0d, 0xb5, 0xd0, 0x97, 0x54, 0x75,
	0x36, 0xd5, 0xd0, 0xd7, 0x68, 0xf2, 0x6a, 0x07, 0xd1, 0x15, 0x85, 0x26, 0xaf, 0x76, 0x34, 0x37,
	0xd9, 0x47, 0x74, 0x55, 0x73, 0x93, 0xfd, 0x4d, 0x6e, 0x9f, 0x85, 0x86, 0x88, 0x05, 0x09, 0x90,
	0x50, 0x53, 0x27, 0x2f, 0xe1, 0x4d, 0x6e, 0xdf, 0x80, 0x53, 0xf9, 0xf5, 0x0f, 0x5e, 0x91, 0x20,
	0xa5, 0x1c, 0xd9, 0xea, 0x32, 0xf2, 0xed, 0x9c, 0xf6, 0xad, 0x24, 0x6d, 0x72, 0x27, 0x82, 0xda,
	0xaa, 0xeb, 0x62, 0x20, 0x9e, 0x83, 0x66, 0x94, 0x86, 0x83, 0xed, 0x20, 0x7e, 0xcd, 0xe5, 0xde,
	0x3b, 0x6e, 0x23, 0x4a, 0x43, 0x2c, 0x0b, 0x1c, 0x2f, 0xfb, 0x65, 0x4a, 0x22, 0x91, 0x86, 0xd9,
	0x65, 0x6b, 0xd0, 0xfe, 0x14, 0x4e, 0xa2, 0x93, 0x28, 0x36, 0x78, 0x99, 0xd2, 0x94, 0x0e, 0xb8,
	0xff, 0x9d, 0x4a, 0x9e, 0x1d, 0x77, 0x2e, 0x24, 0xfb, 0xa8, 0xe0, 0x29, 0x12, 0xb6, 0xfc, 0xef,
	0xa8, 0xf3, 0x31, 0x74, 0x56, 0x5d, 0xf7, 0xa9, 0x12, 0x46, 0xb3, 0x05, 0xcd, 0xca, 0x68, 0x06,
	0x3a, 0x5f, 0xc1, 0xfc, 0xaa, 0xeb, 0x6e, 0x4c, 0x68, 0x40, 0x99, 0x2b, 0x30, 0x83, 0x36, 0x0b,
	0xe6, 0x94, 0x68, 0x3b, 0x24, 0xfb, 0xb9, 0xa9, 0xcf, 0xe1, 0x6c, 0x3f, 0x66, 0xe2, 0x71, 0x34,
	0x3a, 0x72, 0x4d, 0x5b, 0x82, 0x9e, 0x94, 0x3f, 0x8e, 0xcc, 0x67, 0x70, 0x46, 0xca, 0x1c, 0x59,
	0xe0, 0x13, 0x98, 0x9f, 0x10, 0xc8, 0xf6, 0x65, 0x43, 0xc5, 0xec, 0xa6, 0xe2, 0xca, 0xb5, 0xd3,
	0x83, 0x6e, 0x91, 0x1b, 0x03, 0x5a, 0x10, 0x91, 0x62, 0x3d, 0x74, 0x7e, 0xb0, 0xe0, 0xc2, 0x54,
	0x62, 0x31, 0xf7, 0x4d, 0x09, 0xe6, 0xcc, 0x4e, 0x29, 0xb7, 0x63, 0xf7, 0xa0, 0x41, 0x23, 0x79,
	0xa2, 0x9e, 0x0e, 0x4e, 0x03, 0x23, 0xcd, 0xa3, 0x9a, 0xa6, 0x22, 0xd4, 0xc0, 0x78, 0x7f, 0x1e,
	0x8b, 0x93, 0x84, 0x7a, 0x3a, 0x4a, 0x33, 0xd0, 0xb9, 0x00, 0xe7, 0x5c, 0x12, 0x79, 0x71, 0xf8,
	0x3c, 0xf1, 0x64, 0x3a, 0x1c, 0x2f, 0x72, 0x5d, 0x98, 0x77, 0xe9, 0x6b, 0xe6, 0xbf, 0x49, 0x39,
	0x03, 0xa7, 0xa7, 0x8b, 0xfc, 0x68, 0x41, 0xef, 0x85, 0x1f, 0x78, 0x23, 0xc2, 0xbc, 0x23, 0x76,
	0x69, 0x3d, 0x68, 0x24, 0xcc, 0x8f, 0x99, 0x2f, 0x0e, 0x74, 0xda, 0x36, 0x30, 0xf6, 0x5d, 0xea,
	0x13, 0x91, 0x79, 0xf2, 0x90, 0xbe, 0x4b, 0x71, 0xd8, 0xd7, 0xa0, 0x1a, 0x12, 0xbe, 0x87, 0x5f,
	0xe8, 0x61, 0xac, 0x8a, 0xc1, 0x49, 0xe1, 0xc2, 0x34, 0x1f, 0xc7, 0xda, 0x3d, 0x6d, 0xd6, 0x3a,
	0xba, 0xd9, 0xd2, 0xbb, 0xcc, 0x5e, 0x84, 0xf3, 0xd3, 0xcc, 0x9a, 0xb3, 0xfb, 0x12, 0x3e, 0x9a,
	0x46, 0x3f, 0x5a, 0x7b, 0xf8, 0x6f, 0x0b, 0x6a, 0xcb, 0x0f, 0x9e, 0x28, 0xef, 0xab, 0x2c, 0x0d,
	0x8c, 0xf3, 0xa7, 0x8c, 0x47, 0x8a, 0xbe, 0xe8, 0xa6, 0x01, 0x75, 0x15, 0x4b, 0xef, 0xef, 0x16,
	0x54, 0x10, 0xc6, 0x4c, 0xc6, 0xd9, 0x68, 0xe0, 0x27, 0xba, 0x9e, 0x56, 0x39, 0x1b, 0x3d, 0x4e,
	0x10, 0xed, 0x71, 0x81, 0xe8, 0x92, 0x42, 0x7b, 0x5c, 0x3c, 0x4e, 0x30, 0xc1, 0x21, 0x77, 0x12,
	0x33, 0xa1, 0xf3, 0x48, 0x9d, 0xb3, 0x11, 0x7e, 0xcb, 0x48, 0x42, 0x09, 0x49, 0xaa, 0x28, 0x92,
	0xc7, 0x85, 0x24, 0x2d, 0x40, 0x0b, 0x2b, 0xd3, 0x30, 0xf0, 0xf9, 0xae, 0x0e, 0xc6, 0x86, 0x5b,
	0x44, 0xe1, 0xce, 0x30, 0x36, 0x65, 0xd2, 0x6c, 0xb8, 0x72, 0xed, 0xfc, 0xc5, 0x82, 0xda, 0x4a,
	0xff, 0x21, 0xee, 0xec, 0x06, 0xd4, 0xb7, 0xfd, 0x40, 0x50, 0x96, 0xed, 0x6d, 0xde, 0xec, 0x4d,
	0x71, 0x2c, 0x3e, 0x94, 0x64, 0x37, 0x63, 0xeb, 0xf5, 0xa1, 0xa6, 0x50, 0x63, 0x61, 0x66, 0x4d,
	0x84, 0xd9, 0x3c, 0x76, 0xbe, 0xc8, 0xa5, 0x77, 0xa9, 0xa1, 0xb1, 0x3e, 0x33, 0x6b, 0x80, 0x5a,
	0xd0, 0x5c, 0x49, 0xb7, 0xb7, 0xa9, 0xbc, 0xb2, 0x3f, 0x59, 0xd0, 0x5c, 0x39, 0x48, 0x08, 0x97,
	0xcd, 0xef, 0x35, 0x98, 0x1b, 0x1d, 0x8c, 0x02, 0xca, 0xb1, 0xc2, 0x0f, 0x86, 0x78, 0x87, 0x3a,
	0xed, 0xcd, 0x28, 0x7c, 0x9f, 0xb2, 0x15, 0xc4, 0xda, 0xd7, 0xe1, 0x83, 0x02, 0xa7, 0xaa, 0xca,
	0xd2, 0x76, 0xc7, 0x9d, 0x35, 0xac, 0x7d, 0x89, 0xb6, 0xaf, 0xc2, 0x6c, 0x51, 0xeb, 0x81, 0xc8,
	0x52, 0x77, 0x27, 0x57, 0x7a, 0x20, 0xa8, 0xf3, 0x11, 0xd4, 0x57, 0xd3, 0x50, 0xf6, 0x61, 0x3d,
	0x68, 0xf8, 0x91, 0xa0, 0xec, 0x15, 0x09, 0x74, 0x57, 0x60, 0x60, 0x67, 0x16, 0x3a, 0x6b, 0x62,
	0x97, 0xb2, 0xb5, 0x68, 0x44, 0x90, 0xd9, 0x21, 0xd0, 0xc9, 0x47, 0x12, 0x94, 0xce, 0xe7, 0x00,
	0xeb, 0x6d, 0x73, 0xc0, 0x31, 0x22, 0x3f, 0x84, 0xb9, 0xe2, 0xd4, 0x13, 0x6d, 0xfb, 0x3b, 0xf6,
	0x87, 0xd0, 0xf6, 0x54, 0x58, 0x0f, 0x0a, 0xc1, 0xdc, 0xf2, 0xf2, 0x50, 0xb7, 0x6f, 0x65, 0x81,
	0xac, 0x0c, 0x2c, 0x18, 0x03, 0x87, 0x0c, 0x81, 0x3a, 0xa8, 0x9d, 0xff, 0x94, 0x00, 0xf4, 0xac,
	0xa4, 0x4f, 0x43, 0xd0, 0x30, 0x09, 0x32, 0x2b, 0x6d, 0xd7, 0xc0, 0xf6, 0x1c, 0x94, 0x93, 0x44,
	0xb5, 0x47, 0x96, 0x8b, 0x4b, 0x2c, 0xb2, 0xb2, 0x52, 0xb2, 0xec, 0xe2, 0x2d, 0xb7, 0x81, 0x08,
	0x17, 0xd9, 0x2f, 0x43, 0x47, 0x12, 0xbd, 0x94, 0x11, 0x6c, 0x18, 0x64, 0x84, 0x5b, 0x6e, 0x1b,
	0x91, 0xab, 0x1a, 0x87, 0xf9, 0x96, 0x30, 0xe6, 0xe3, 0xe1, 0x57, 0x65, 0x38, 0x65, 0xa0, 0xcc,
	0xd2, 0x99, 0x64, 0x4d, 0x92, 0x0c, 0x8c, 0xe7, 0xf1, 0x32, 0xf5, 0x47, 0x7b, 0x03, 0x46, 0xc2,
	0x24, 0x4d, 0xba, 0x75, 0xf5, 0x75, 0x48, 0x9c, 0x2b, 0x51, 0xf6, 0x02, 0xb4, 0xfd, 0x64, 0x80,
	0x1f, 0x9e, 0x6a, 0x71, 0x1a, 0x32, 0x0c, 0xc0, 0x4f, 0xb6, 0xd8, 0x48, 0xb5, 0x38, 0x8a, 0x03,
	0xbf, 0x3f, 0xc5, 0xd1, 0xcc, 0x38, 0x56, 0xb9, 0x50, 0x1c, 0x57, 0x60, 0x06, 0x3f, 0xcd, 0x82,
	0x16, 0x50, 0x85, 0x19, 0xb1, 0x46, 0x4f, 0xc6, 0x95, 0x6b, 0x6a, 0xe5, 0x5c, 0x99, 0x2e, 0xe7,
	0x27, 0x30, 0xfb, 0x88, 0x46, 0x94, 0xf9, 0xa3, 0x55, 0xaa, 0x82, 0x49, 0xd6, 0xd3, 0x03, 0xd5,
	0xc9, 0xab, 0x7a, 0x8a, 0x80, 0xf3, 0x2f, 0xcb, 0x70, 0x66, 0x61, 0x67, 0x7f, 0x39, 0x11, 0x65,
	0x97, 0xcd, 0xed, 0x4e, 0x70, 0x2e, 0xca, 0xc5, 0x58, 0xe8, 0xf5, 0x0e, 0x00, 0x72, 0xec, 0xb4,
	0xa2, 0x6c, 0x5f, 0x84, 0x26, 0x11, 0x82, 0xf9, 0xc3, 0x54, 0x0f, 0x4b, 0xcd, 0xf5, 0x13, 0x6e,
	0x8e, 0xc2, 0x24, 0x29, 0x13, 0xb8, 0xbc, 0xe2, 0xa9, 0xc1, 0xbb, 0x7e, 0xc2, 0x55, 0x2c, 0x2b,
	0x2d, 0x68, 0xfa, 0x11, 0xa7, 0x0c, 0xef, 0xc9, 0xf9, 0x35, 0x34, 0xd5, 0xf4, 0x7b, 0xe8, 0xb8,
	0x6b, 0x86, 0xeb, 0xd2, 0xd4, 0xe1, 0xba, 0xfc, 0xd6, 0xe1, 0xba, 0x0d, 0xf0, 0xb8, 0x6f, 0xbe,
	0xcd, 0x47, 0xd0, 0xca, 0x26, 0x50, 0xdd, 0x00, 0x62, 0x57, 0x95, 0x65, 0x77, 0xd9, 0x00, 0x86,
	0x64, 0x1f, 0x13, 0x38, 0xcf, 0x88, 0x62, 0x18, 0xdc, 0xe1, 0x3a, 0x97, 0x20, 0xf1, 0x19, 0xc2,
	0x4e, 0x1f, 0xda, 0x66, 0x96, 0x9a, 0xec, 0x63, 0xca, 0xfa, 0xc8, 0xe6, 0xa1, 0x36, 0x4c, 0x4d,
	0x26, 0x2a, 0xbb, 0x1a, 0xc2, 0x4d, 0x62, 0x89, 0x8a, 0xe4, 0x51, 0x35, 0x5c, 0x05, 0xa0, 0xa3,
	0x1b, 0xcb, 0x0f, 0xb6, 0x5e, 0x2b, 0x47, 0xff, 0x61, 0x01, 0xe8, 0xbe, 0x5e, 0x0f, 0xdc, 0xf1,
	0xf6, 0x36, 0xd7, 0xaa, 0x2a, 0xae, 0x86, 0xec, 0x4f, 0xcc, 0x0c, 0xc4, 0x49, 0x98, 0x04, 0x74,
	0x90, 0xb0, 0x78, 0xa8, 0xbf, 0xb2, 0x39, 0x45, 0xd9, 0x92, 0x84, 0x3e, 0x8b, 0x87, 0x18, 0x85,
	0xd9, 0x88, 0x15, 0xf1, 0x41, 0x48, 0xf6, 0x75, 0x6b, 0xd3, 0xd6, 0xd8, 0x4d, 0xbe, 0x41, 0xf6,
	0xed, 0x25, 0x38, 0x5d, 0xe0, 0xca, 0x9b, 0x79, 0xf9, 0xf1, 0x75, 0xdc, 0x93, 0x86, 0xd9, 0x35,
	0x24, 0x07, 0xa0, 0xb1, 0x41, 0xd9, 0x0e, 0xfa, 0xea, 0xfc, 0xb7, 0x04, 0xb3, 0x1b, 0x54, 0x10,
	0x8f, 0x08, 0xf2, 0x8c, 0xaa, 0xb6, 0xf0, 0x16, 0x54, 0x18, 0x25, 0x9e, 0x0e, 0x4d, 0xa7, 0x30,
	0xba, 0x8c, 0xf1, 0x2d, 0xba, 0x94, 0x78, 0x6a, 0x7a, 0x97, 0xfc, 0xf6, 0x5d, 0xa8, 0xca, 0x7e,
	0x49, 0x67, 0xac, 0xcb, 0x87, 0x0a, 0xbe, 0x40, 0x2e, 0x25, 0xa9, 0x24, 0xec, 0x7b, 0x50, 0x4b,
	0x65, 0x4b, 0xa5, 0x03, 0xe4, 0xca, 0xa1, 0xb2, 0xaa, 0xf3, 0x52, 0xc2, 0x5a, 0xa6, 0x77, 0x1b,
	0x9a, 0xc6, 0x17, 0x4c, 0x6a, 0x7b, 0xf4, 0x40, 0x17, 0x72, 0x5c, 0xe2, 0x15, 0xaa, 0x68, 0xd7,
	0x73, 0xb1, 0x04, 0xbe, 0x28, 0xdd, 0xb1, 0x7a, 0x77, 0x00, 0x72, 0x5f, 0x8e, 0x25, 0x79, 0x17,
	0x5a, 0x05, 0x4f, 0x8e, 0x23, 0xea, 0xfc, 0xbe, 0x04, 0xb5, 0xcd, 0xe5, 0x67, 0x78, 0xd2, 0xf7,
	0xa0, 0x49, 0xf7, 0xc5, 0x20, 0x7f, 0x36, 0x68, 0x2d, 0x5d, 0x32, 0x3b, 0x57, 0x3c, 0x8b, 0x6b,
	0xfb, 0x82, 0xb2, 0x88, 0x04, 0xcb, 0x9e, 0xc7, 0x28, 0xe7, 0x6e, 0x83, 0xee, 0x0b, 0x5c, 0xf3,
	0xde, 0x53, 0x68, 0x62, 0x67, 0xa1, 0x92, 0x16, 0xe6, 0x1e, 0xba, 0xe3, 0x47, 0xfa, 0xcb, 0x50,
	0x00, 0xfa, 0x45, 0x23, 0x4f, 0x7f, 0x10, 0xb8, 0xc4, 0xa1, 0x99, 0xa7, 0x3c, 0xa1, 0x91, 0xa7,
	0x1b, 0xe9, 0x86, 0x9b, 0x23, 0x7a, 0xbb, 0x30, 0x3b, 0x61, 0x0f, 0x5b, 0x9a, 0xcc, 0x47, 0xbd,
	0xbf, 0xba, 0xf6, 0xc0, 0xfe, 0x02, 0x5a, 0x32, 0x51, 0xca, 0x24, 0x99, 0x15, 0xaa, 0xb3, 0x93,
	0x1b, 0x30, 0x3e, 0xba, 0x90, 0x64, 0x4b, 0xee, 0xfc, 0x50, 0x82, 0x36, 0x0e, 0x03, 0xfe, 0xc8,
	0x9c, 0x45, 0x35, 0x21, 0xbe, 0x39, 0x87, 0xab, 0x46, 0x4d, 0x91, 0x6b, 0x31, 0x3b, 0x05, 0x54,
	0xd2, 0x27, 0x3e, 0x73, 0x95, 0x50, 0xef, 0x16, 0xb4, 0x8b, 0x24, 0x3c, 0x0e, 0x2e, 0x08, 0x13,
	0xa6, 0xa1, 0x43, 0xa0, 0x78, 0x1c, 0x4d, 0x79, 0x1c, 0xbd, 0xbf, 0x5a, 0x30, 0x37, 0xa9, 0xd3,
	0xbe, 0x8f, 0x29, 0x2f, 0xcb, 0xfd, 0x96, 0x4c, 0x91, 0xce, 0xbb, 0xdd, 0x91, 0x6d, 0x86, 0xb2,
	0x7e, 0x5f, 0xdd, 0x6b, 0x3e, 0x8b, 0x1f, 0x51, 0x01, 0xdd, 0xd7, 0xc5, 0xa5, 0x09, 0xf5, 0xcd,
	0xf8, 0x1b, 0x99, 0x5c, 0xee, 0x01, 0xe8, 0x31, 0x51, 0xa7, 0x2e, 0xd9, 0x5c, 0xea, 0x77, 0x1f,
	0x5c, 0xab, 0xe6, 0x8e, 0x6e, 0x53, 0xec, 0xb8, 0x4a, 0xf2, 0x46, 0x0d, 0xec, 0x2c, 0x28, 0xe9,
	0x6f, 0x52, 0x71, 0x88, 0xb4, 0xf3, 0x0d, 0xb4, 0xb2, 0x99, 0xf2, 0x30, 0x03, 0x73, 0x50, 0x7e,
	0xe9, 0x7b, 0x3a, 0x9b, 0xe1, 0x72, 0xcc, 0x64, 0x79, 0xc2, 0xe4, 0x4d, 0xad, 0xf0, 0x70, 0x9b,
	0x6f, 0x2a, 0x74, 0x7e, 0x03, 0x0d, 0x29, 0x74, 0xc8, 0x98, 0xf9, 0xb6, 0x3d, 0xda, 0x0e, 0xb4,
	0x87, 0x64, 0xb4, 0x97, 0xe0, 0x41, 0xa6, 0x8c, 0x6a, 0x87, 0xc6, 0x70, 0xce, 0x03, 0x98, 0x51,
	0xc3, 0xde, 0x56, 0x12, 0xf8, 0x42, 0x97, 0x13, 0xec, 0xb0, 0x55, 0xab, 0xa3, 0xfb, 0x44, 0x44,
	0xc8, 0x56, 0xc7, 0x94, 0xb6, 0x52, 0xf1, 0x25, 0xf7, 0x3e, 0x2c, 0x14, 0x94, 0x14, 0x26, 0x14,
	0x16, 0x27, 0x4c, 0x8f, 0x27, 0x6f, 0x53, 0xeb, 0xfc, 0x0c, 0x2e, 0x4c, 0x55, 0xf0, 0x8e, 0x17,
	0xe4, 0x1f, 0x2d, 0x98, 0x2d, 0x8e, 0xaa, 0x2a, 0x49, 0x8f, 0x77, 0x10, 0x17, 0x4d, 0x7c, 0x4d,
	0x70, 0x8e, 0x97, 0xd8, 0xde, 0x0b, 0xa8, 0xaa, 0xbe, 0x21, 0xaf, 0x52, 0xaa, 0x0c, 0x66, 0x55,
	0x6a, 0xda, 0xf0, 0x3d, 0x07, 0xe5, 0xd0, 0x8f, 0xf4, 0xdc, 0x8d, 0x4b, 0x89, 0x31, 0x25, 0x09,
	0x97, 0xce, 0x75, 0x00, 0x3d, 0x2f, 0xa3, 0x7b, 0xe7, 0xa1, 0x99, 0xb5, 0x99, 0xca, 0xc3, 0xb6,
	0x9b, 0x23, 0x9c, 0x9f, 0xc2, 0x79, 0x37, 0x4e, 0x23, 0xcf, 0x8d, 0x87, 0x7e, 0x74, 0xe4, 0x63,
	0xf8, 0x1c, 0xce, 0x4d, 0x93, 0x7a, 0xcb, 0xab, 0xbe, 0x73, 0x17, 0x3a, 0xb9, 0xc8, 0xb1, 0x7a,
	0x16, 0xe7, 0x0a, 0xb4, 0x5d, 0x9a, 0x04, 0xfe, 0x88, 0x98, 0xa7, 0xe4, 0x29, 0x3e, 0xdd, 0x84,
	0x73, 0x86, 0xeb, 0xc8, 0x1b, 0xf9, 0xbe, 0x04, 0x33, 0xe8, 0xb8, 0x2e, 0x6d, 0xc8, 0x78, 0x1b,
	0xaa, 0xd8, 0x9e, 0x65, 0xb7, 0xf9, 0x61, 0x9e, 0x2d, 0xc6, 0xf8, 0x16, 0x97, 0xb3, 0x1e, 0xce,
	0x55, 0xfc, 0xbd, 0x7f, 0x5a, 0xd0, 0x34, 0x48, 0xdc, 0x48, 0x44, 0x42, 0x73, 0x06, 0xb8, 0x9e,
	0x7a, 0xa1, 0x17, 0xa0, 0x29, 0x0b, 0xd2, 0xc0, 0xd7, 0x6f, 0xc2, 0x95, 0xf5, 0x13, 0x6e, 0x43,
	0xa2, 0x1e, 0xcb, 0x37, 0x63, 0x4d, 0x1e, 0xfa, 0xaa, 0xcb, 0x6f, 0x1b, 0xf2, 0x8a, 0x1f, 0x15,
	0x42, 0x07, 0xbb, 0x8c, 0x6a, 0x31, 0x74, 0x70, 0xe4, 0x91, 0xdd, 0x7d, 0xdb, 0x95, 0x6b, 0xfb,
	0x12, 0xb4, 0x18, 0xdf, 0xf5, 0xb7, 0xc5, 0x40, 0xbe, 0xb9, 0xd6, 0xa5, 0x00, 0x28, 0xd4, 0x8a,
	0x2f, 0xf8, 0x4a, 0x5d, 0x17, 0x4a, 0xcc, 0x79, 0x5b, 0x7e, 0xb4, 0x87, 0x39, 0xef, 0x06, 0x74,
	0xb7, 0xe2, 0x94, 0x8d, 0x8e, 0xfe, 0x68, 0x75, 0x1b, 0x7a, 0x93, 0x12, 0xfd, 0x3d, 0xf3, 0x70,
	0x75, 0x16, 0x1a, 0xc9, 0x9e, 0x18, 0x14, 0xb2, 0x4a, 0x3d, 0x51, 0x54, 0xe7, 0x2a, 0x34, 0x95,
	0xe0, 0x3b, 0xf8, 0x7e, 0x0b, 0x0d, 0x93, 0x3a, 0xde, 0xa7, 0xe5, 0xee, 0x9a, 0x33, 0x93, 0xf3,
	0xf4, 0xfa, 0x89, 0xec, 0xd4, 0x56, 0x6a, 0x50, 0x11, 0x07, 0x09, 0x7a, 0xd2, 0x7e, 0x96, 0xbd,
	0x5e, 0x8f, 0xb7, 0x91, 0x56, 0xb1, 0x8d, 0x74, 0xfe, 0x68, 0x41, 0x33, 0xcf, 0x03, 0x37, 0x26,
	0xf2, 0x40, 0xd7, 0x44, 0xce, 0x61, 0x19, 0xe0, 0xf1, 0xfb, 0x64, 0x80, 0x53, 0xc5, 0x89, 0xa1,
	0xa2, 0xdb, 0x19, 0xe7, 0x15, 0xb4, 0x9f, 0xb3, 0x40, 0xbd, 0x31, 0xa8, 0x28, 0x6e, 0x0e, 0x03,
	0x32, 0xda, 0x0b, 0x7c, 0x79, 0x3f, 0xe3, 0xed, 0x40, 0x91, 0x13, 0x01, 0x37, 0xe7, 0xed, 0x7d,
	0x0a, 0xe5, 0xe7, 0x2c, 0x40, 0xcb, 0xbb, 0x31, 0x37, 0xb5, 0x02, 0xd7, 0xb2, 0x7e, 0x10, 0xb1,
	0x9b, 0x7d, 0x9b, 0xb8, 0x76, 0x7e, 0x0e, 0xb3, 0x46, 0x9b, 0x9e, 0xa8, 0xdf, 0xd7, 0x34, 0xb6,
	0xf2, 0xdf, 0x3e, 0x59, 0xde, 0xec, 0xc7, 0xb2, 0xda, 0x5e, 0x82, 0x96, 0x84, 0x52, 0x2e, 0x5f,
	0x03, 0xe6, 0xa0, 0x2c, 0x46, 0xbe, 0xbe, 0x00, 0x5c, 0x3a, 0x33, 0xd0, 0x46, 0x86, 0x2c, 0x16,
	0x9c, 0x59, 0xe8, 0x7c, 0xfb, 0x8b, 0x27, 0xcb, 0x9b, 0xd9, 0x10, 0xe8, 0x7c, 0xac, 0x11, 0x66,
	0xd6, 0xeb, 0x42, 0xdd, 0xe3, 0xc2, 0xd4, 0xc0, 0x8a, 0x9b, 0x81, 0xce, 0x17, 0x30, 0x37, 0xf6,
	0xe6, 0x75, 0x8c, 0xf7, 0x07, 0x87, 0xc3, 0xc9, 0x89, 0xf7, 0xb2, 0xa3, 0x3e, 0x2c, 0xdc, 0x1d,
	0x7f, 0x58, 0xc8, 0xdb, 0xf4, 0xc3, 0x9f, 0x2e, 0xb3, 0xb7, 0x85, 0x7b, 0x30, 0xbb, 0xcc, 0xf4,
	0x9f, 0x2b, 0x4f, 0x5d, 0xf9, 0x0c, 0x94, 0xcc, 0xb3, 0x59, 0xc9, 0x97, 0x8f, 0x63, 0x21, 0x19,
	0xa9, 0x76, 0x51, 0x5d, 0x59, 0x3d, 0x24, 0x23, 0x6c, 0x73, 0x9c, 0x5f, 0x01, 0x6c, 0x24, 0x01,
	0x57, 0x27, 0x6d, 0x5f, 0x87, 0x0f, 0x18, 0x0d, 0xe3, 0x57, 0x74, 0x40, 0xc5, 0xee, 0x60, 0x97,
	0x12, 0x8f, 0x66, 0x3f, 0x99, 0x66, 0x15, 0x61, 0x4d, 0xec, 0xae, 0x4b, 0xb4, 0xed, 0x40, 0x27,
	0xc2, 0x86, 0x0a, 0x39, 0xf1, 0x5b, 0xd1, 0x0d, 0x6d, 0x0b, 0x91, 0x6b, 0x62, 0xf7, 0x19, 0x7e,
	0x3e, 0x7f, 0xb3, 0x60, 0xe6, 0x45, 0xcc, 0xf6, 0x28, 0x33, 0xdf, 0xe9, 0xd7, 0xd0, 0x7e, 0x2d,
	0x31, 0x83, 0x3c, 0x09, 0xb7, 0x96, 0xae, 0xe5, 0x1b, 0x1e, 0x63, 0xd7, 0xa0, 0xcc, 0xdd, 0x6a,
	0xbe, 0x68, 0xbd, 0xce, 0x31, 0xbd, 0xaf, 0x60, 0x6e, 0x92, 0xa1, 0xd8, 0xf6, 0x77, 0xa6, 0xb4,
	0xfd, 0x9d, 0x42, 0xdb, 0x3f, 0xac, 0xc9, 0xff, 0xfc, 0x37, 0xff, 0x1f, 0x00, 0x00, 0xff, 0xff,
	0x5f, 0xda, 0xf5, 0x9b, 0x14, 0x20, 0x00, 0x00,
}
