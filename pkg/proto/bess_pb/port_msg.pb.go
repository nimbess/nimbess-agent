// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ports/port_msg.proto

/*
Package bess_pb is a generated protocol buffer package.

It is generated from these files:
	ports/port_msg.proto

It has these top-level messages:
	PCAPPortArg
	PMDPortArg
	UnixSocketPortArg
	VPortArg
*/
package bess_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PCAPPortArg struct {
	Dev string `protobuf:"bytes,1,opt,name=dev" json:"dev,omitempty"`
}

func (m *PCAPPortArg) Reset()                    { *m = PCAPPortArg{} }
func (m *PCAPPortArg) String() string            { return proto.CompactTextString(m) }
func (*PCAPPortArg) ProtoMessage()               {}
func (*PCAPPortArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PCAPPortArg) GetDev() string {
	if m != nil {
		return m.Dev
	}
	return ""
}

type PMDPortArg struct {
	Loopback bool `protobuf:"varint,1,opt,name=loopback" json:"loopback,omitempty"`
	// Types that are valid to be assigned to Port:
	//	*PMDPortArg_PortId
	//	*PMDPortArg_Pci
	//	*PMDPortArg_Vdev
	Port isPMDPortArg_Port `protobuf_oneof:"port"`
	// See http://dpdk.org/doc/dts/test_plans/dual_vlan_test_plan.html
	VlanOffloadRxStrip  bool `protobuf:"varint,5,opt,name=vlan_offload_rx_strip,json=vlanOffloadRxStrip" json:"vlan_offload_rx_strip,omitempty"`
	VlanOffloadRxFilter bool `protobuf:"varint,6,opt,name=vlan_offload_rx_filter,json=vlanOffloadRxFilter" json:"vlan_offload_rx_filter,omitempty"`
	VlanOffloadRxQinq   bool `protobuf:"varint,7,opt,name=vlan_offload_rx_qinq,json=vlanOffloadRxQinq" json:"vlan_offload_rx_qinq,omitempty"`
}

func (m *PMDPortArg) Reset()                    { *m = PMDPortArg{} }
func (m *PMDPortArg) String() string            { return proto.CompactTextString(m) }
func (*PMDPortArg) ProtoMessage()               {}
func (*PMDPortArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isPMDPortArg_Port interface{ isPMDPortArg_Port() }

type PMDPortArg_PortId struct {
	PortId uint64 `protobuf:"varint,2,opt,name=port_id,json=portId,oneof"`
}
type PMDPortArg_Pci struct {
	Pci string `protobuf:"bytes,3,opt,name=pci,oneof"`
}
type PMDPortArg_Vdev struct {
	Vdev string `protobuf:"bytes,4,opt,name=vdev,oneof"`
}

func (*PMDPortArg_PortId) isPMDPortArg_Port() {}
func (*PMDPortArg_Pci) isPMDPortArg_Port()    {}
func (*PMDPortArg_Vdev) isPMDPortArg_Port()   {}

func (m *PMDPortArg) GetPort() isPMDPortArg_Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *PMDPortArg) GetLoopback() bool {
	if m != nil {
		return m.Loopback
	}
	return false
}

func (m *PMDPortArg) GetPortId() uint64 {
	if x, ok := m.GetPort().(*PMDPortArg_PortId); ok {
		return x.PortId
	}
	return 0
}

func (m *PMDPortArg) GetPci() string {
	if x, ok := m.GetPort().(*PMDPortArg_Pci); ok {
		return x.Pci
	}
	return ""
}

func (m *PMDPortArg) GetVdev() string {
	if x, ok := m.GetPort().(*PMDPortArg_Vdev); ok {
		return x.Vdev
	}
	return ""
}

func (m *PMDPortArg) GetVlanOffloadRxStrip() bool {
	if m != nil {
		return m.VlanOffloadRxStrip
	}
	return false
}

func (m *PMDPortArg) GetVlanOffloadRxFilter() bool {
	if m != nil {
		return m.VlanOffloadRxFilter
	}
	return false
}

func (m *PMDPortArg) GetVlanOffloadRxQinq() bool {
	if m != nil {
		return m.VlanOffloadRxQinq
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PMDPortArg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PMDPortArg_OneofMarshaler, _PMDPortArg_OneofUnmarshaler, _PMDPortArg_OneofSizer, []interface{}{
		(*PMDPortArg_PortId)(nil),
		(*PMDPortArg_Pci)(nil),
		(*PMDPortArg_Vdev)(nil),
	}
}

func _PMDPortArg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PMDPortArg)
	// port
	switch x := m.Port.(type) {
	case *PMDPortArg_PortId:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.PortId))
	case *PMDPortArg_Pci:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Pci)
	case *PMDPortArg_Vdev:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Vdev)
	case nil:
	default:
		return fmt.Errorf("PMDPortArg.Port has unexpected type %T", x)
	}
	return nil
}

func _PMDPortArg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PMDPortArg)
	switch tag {
	case 2: // port.port_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Port = &PMDPortArg_PortId{x}
		return true, err
	case 3: // port.pci
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Port = &PMDPortArg_Pci{x}
		return true, err
	case 4: // port.vdev
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Port = &PMDPortArg_Vdev{x}
		return true, err
	default:
		return false, nil
	}
}

func _PMDPortArg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PMDPortArg)
	// port
	switch x := m.Port.(type) {
	case *PMDPortArg_PortId:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.PortId))
	case *PMDPortArg_Pci:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Pci)))
		n += len(x.Pci)
	case *PMDPortArg_Vdev:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Vdev)))
		n += len(x.Vdev)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type UnixSocketPortArg struct {
	// / Set the first character to "@" in place of \0 for abstract path
	// / See manpage for unix(7).
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// / Minimum RX polling interval for system calls, when *idle*.
	// / Use a negative number for unthrottled polling. If unspecified or 0,
	// / it is set to 50,000 (50 microseconds, or 20k polls per second)
	MinRxIntervalNs int64 `protobuf:"varint,2,opt,name=min_rx_interval_ns,json=minRxIntervalNs" json:"min_rx_interval_ns,omitempty"`
	// / If set, the port driver will send a confirmation once
	// / the port is connected.  This lets pybess avoid a race during
	// / testing.  See bessctl/test_utils.py for details.
	ConfirmConnect bool `protobuf:"varint,3,opt,name=confirm_connect,json=confirmConnect" json:"confirm_connect,omitempty"`
}

func (m *UnixSocketPortArg) Reset()                    { *m = UnixSocketPortArg{} }
func (m *UnixSocketPortArg) String() string            { return proto.CompactTextString(m) }
func (*UnixSocketPortArg) ProtoMessage()               {}
func (*UnixSocketPortArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UnixSocketPortArg) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *UnixSocketPortArg) GetMinRxIntervalNs() int64 {
	if m != nil {
		return m.MinRxIntervalNs
	}
	return 0
}

func (m *UnixSocketPortArg) GetConfirmConnect() bool {
	if m != nil {
		return m.ConfirmConnect
	}
	return false
}

type VPortArg struct {
	Ifname string `protobuf:"bytes,1,opt,name=ifname" json:"ifname,omitempty"`
	// Types that are valid to be assigned to Cpid:
	//	*VPortArg_Docker
	//	*VPortArg_ContainerPid
	//	*VPortArg_Netns
	Cpid       isVPortArg_Cpid `protobuf_oneof:"cpid"`
	RxqCpus    []int64         `protobuf:"varint,5,rep,packed,name=rxq_cpus,json=rxqCpus" json:"rxq_cpus,omitempty"`
	TxTci      uint64          `protobuf:"varint,6,opt,name=tx_tci,json=txTci" json:"tx_tci,omitempty"`
	TxOuterTci uint64          `protobuf:"varint,7,opt,name=tx_outer_tci,json=txOuterTci" json:"tx_outer_tci,omitempty"`
	Loopback   bool            `protobuf:"varint,8,opt,name=loopback" json:"loopback,omitempty"`
	IpAddrs    []string        `protobuf:"bytes,9,rep,name=ip_addrs,json=ipAddrs" json:"ip_addrs,omitempty"`
}

func (m *VPortArg) Reset()                    { *m = VPortArg{} }
func (m *VPortArg) String() string            { return proto.CompactTextString(m) }
func (*VPortArg) ProtoMessage()               {}
func (*VPortArg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isVPortArg_Cpid interface{ isVPortArg_Cpid() }

type VPortArg_Docker struct {
	Docker string `protobuf:"bytes,2,opt,name=docker,oneof"`
}
type VPortArg_ContainerPid struct {
	ContainerPid int64 `protobuf:"varint,3,opt,name=container_pid,json=containerPid,oneof"`
}
type VPortArg_Netns struct {
	Netns string `protobuf:"bytes,4,opt,name=netns,oneof"`
}

func (*VPortArg_Docker) isVPortArg_Cpid()       {}
func (*VPortArg_ContainerPid) isVPortArg_Cpid() {}
func (*VPortArg_Netns) isVPortArg_Cpid()        {}

func (m *VPortArg) GetCpid() isVPortArg_Cpid {
	if m != nil {
		return m.Cpid
	}
	return nil
}

func (m *VPortArg) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

func (m *VPortArg) GetDocker() string {
	if x, ok := m.GetCpid().(*VPortArg_Docker); ok {
		return x.Docker
	}
	return ""
}

func (m *VPortArg) GetContainerPid() int64 {
	if x, ok := m.GetCpid().(*VPortArg_ContainerPid); ok {
		return x.ContainerPid
	}
	return 0
}

func (m *VPortArg) GetNetns() string {
	if x, ok := m.GetCpid().(*VPortArg_Netns); ok {
		return x.Netns
	}
	return ""
}

func (m *VPortArg) GetRxqCpus() []int64 {
	if m != nil {
		return m.RxqCpus
	}
	return nil
}

func (m *VPortArg) GetTxTci() uint64 {
	if m != nil {
		return m.TxTci
	}
	return 0
}

func (m *VPortArg) GetTxOuterTci() uint64 {
	if m != nil {
		return m.TxOuterTci
	}
	return 0
}

func (m *VPortArg) GetLoopback() bool {
	if m != nil {
		return m.Loopback
	}
	return false
}

func (m *VPortArg) GetIpAddrs() []string {
	if m != nil {
		return m.IpAddrs
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VPortArg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VPortArg_OneofMarshaler, _VPortArg_OneofUnmarshaler, _VPortArg_OneofSizer, []interface{}{
		(*VPortArg_Docker)(nil),
		(*VPortArg_ContainerPid)(nil),
		(*VPortArg_Netns)(nil),
	}
}

func _VPortArg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VPortArg)
	// cpid
	switch x := m.Cpid.(type) {
	case *VPortArg_Docker:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Docker)
	case *VPortArg_ContainerPid:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ContainerPid))
	case *VPortArg_Netns:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Netns)
	case nil:
	default:
		return fmt.Errorf("VPortArg.Cpid has unexpected type %T", x)
	}
	return nil
}

func _VPortArg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VPortArg)
	switch tag {
	case 2: // cpid.docker
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Cpid = &VPortArg_Docker{x}
		return true, err
	case 3: // cpid.container_pid
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Cpid = &VPortArg_ContainerPid{int64(x)}
		return true, err
	case 4: // cpid.netns
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Cpid = &VPortArg_Netns{x}
		return true, err
	default:
		return false, nil
	}
}

func _VPortArg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VPortArg)
	// cpid
	switch x := m.Cpid.(type) {
	case *VPortArg_Docker:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Docker)))
		n += len(x.Docker)
	case *VPortArg_ContainerPid:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ContainerPid))
	case *VPortArg_Netns:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Netns)))
		n += len(x.Netns)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*PCAPPortArg)(nil), "bess.pb.PCAPPortArg")
	proto.RegisterType((*PMDPortArg)(nil), "bess.pb.PMDPortArg")
	proto.RegisterType((*UnixSocketPortArg)(nil), "bess.pb.UnixSocketPortArg")
	proto.RegisterType((*VPortArg)(nil), "bess.pb.VPortArg")
}

func init() { proto.RegisterFile("port_msg.proto", fileDescriptor10) }

var fileDescriptor10 = []byte{
	// 469 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x52, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x5d, 0x97, 0x34, 0x49, 0x2f, 0x83, 0xb1, 0x4b, 0x57, 0x65, 0xbc, 0x50, 0x55, 0x42, 0x54,
	0x42, 0xda, 0x84, 0xf6, 0x05, 0xa5, 0x08, 0x75, 0x0f, 0xb0, 0xe2, 0x01, 0xaf, 0x56, 0xea, 0xa4,
	0xe3, 0x6a, 0xad, 0xed, 0xd8, 0x6e, 0x95, 0x17, 0x7e, 0x81, 0x6f, 0x46, 0x76, 0xd3, 0x8a, 0x8d,
	0x97, 0xca, 0xe7, 0x1c, 0x1f, 0x9f, 0xe6, 0xdc, 0x0b, 0x7d, 0xad, 0x8c, 0xb3, 0x57, 0xfe, 0x97,
	0xaf, 0xed, 0xfd, 0xa5, 0x36, 0xca, 0x29, 0x4c, 0x17, 0x95, 0xb5, 0x97, 0x7a, 0x31, 0x7a, 0x03,
	0xcf, 0xe6, 0xd3, 0xc9, 0x7c, 0xae, 0x8c, 0x9b, 0x98, 0x7b, 0x7c, 0x09, 0x51, 0x59, 0x6d, 0xf3,
	0xce, 0xb0, 0x33, 0xee, 0x31, 0x7f, 0x1c, 0xfd, 0x39, 0x06, 0x98, 0x7f, 0xf9, 0xb4, 0xbf, 0xf0,
	0x1a, 0xb2, 0x95, 0x52, 0x7a, 0x51, 0x88, 0x87, 0x70, 0x2b, 0x63, 0x07, 0x8c, 0x17, 0x90, 0x86,
	0x18, 0x2a, 0xf3, 0xe3, 0x61, 0x67, 0x1c, 0xcf, 0x8e, 0x58, 0xe2, 0x89, 0x9b, 0x12, 0x11, 0x22,
	0x2d, 0x28, 0x8f, 0xfc, 0xbb, 0xb3, 0x23, 0xe6, 0x01, 0xf6, 0x21, 0xde, 0xfa, 0xb0, 0xb8, 0x25,
	0x03, 0xc2, 0x0f, 0x70, 0xbe, 0x5d, 0x15, 0x92, 0xab, 0xe5, 0x72, 0xa5, 0x8a, 0x92, 0x9b, 0x86,
	0x5b, 0x67, 0x48, 0xe7, 0xdd, 0x90, 0x86, 0x5e, 0xbc, 0xdd, 0x69, 0xac, 0xb9, 0xf3, 0x0a, 0x5e,
	0xc3, 0xe0, 0xa9, 0x65, 0x49, 0x2b, 0x57, 0x99, 0x3c, 0x09, 0x9e, 0x57, 0x8f, 0x3c, 0x9f, 0x83,
	0x84, 0x57, 0xd0, 0x7f, 0x6a, 0xaa, 0x49, 0xd6, 0x79, 0x1a, 0x2c, 0x67, 0x8f, 0x2c, 0xdf, 0x48,
	0xd6, 0x1f, 0x13, 0x88, 0xfd, 0xc7, 0x8c, 0x7e, 0xc3, 0xd9, 0x0f, 0x49, 0xcd, 0x9d, 0x12, 0x0f,
	0x95, 0xdb, 0xd7, 0x82, 0x10, 0xeb, 0xc2, 0xfd, 0x6a, 0x8b, 0x0b, 0x67, 0x7c, 0x0f, 0xb8, 0x26,
	0xe9, 0x1f, 0x26, 0xe9, 0x2a, 0xb3, 0x2d, 0x56, 0x5c, 0xda, 0xd0, 0x4c, 0xc4, 0x4e, 0xd7, 0x24,
	0x59, 0x73, 0xd3, 0xf2, 0x5f, 0x2d, 0xbe, 0x83, 0x53, 0xa1, 0xe4, 0x92, 0xcc, 0x9a, 0x0b, 0x25,
	0x65, 0x25, 0x5c, 0x28, 0x2b, 0x63, 0x2f, 0x5a, 0x7a, 0xba, 0x63, 0xfd, 0x3c, 0xb2, 0x9f, 0xfb,
	0xd8, 0x01, 0x24, 0xb4, 0x94, 0xc5, 0xba, 0x6a, 0x83, 0x5b, 0x84, 0x39, 0x24, 0xa5, 0xff, 0x7f,
	0x26, 0xc4, 0xf9, 0x72, 0x5b, 0x8c, 0x6f, 0xe1, 0xb9, 0x50, 0xd2, 0x15, 0x24, 0x2b, 0xc3, 0x35,
	0x95, 0x21, 0x25, 0x9a, 0x1d, 0xb1, 0x93, 0x03, 0x3d, 0xa7, 0x12, 0x07, 0xd0, 0x95, 0x95, 0x93,
	0xf6, 0x30, 0x9c, 0x1d, 0xc4, 0x0b, 0xc8, 0x4c, 0x53, 0x73, 0xa1, 0x37, 0x36, 0xef, 0x0e, 0xa3,
	0x71, 0xc4, 0x52, 0xd3, 0xd4, 0x53, 0xbd, 0xb1, 0x78, 0x0e, 0x89, 0x6b, 0xb8, 0x13, 0x14, 0x5a,
	0x8f, 0x59, 0xd7, 0x35, 0xdf, 0x05, 0xe1, 0x10, 0x4e, 0x5c, 0xc3, 0xd5, 0xc6, 0x55, 0x26, 0x88,
	0x69, 0x10, 0xc1, 0x35, 0xb7, 0x9e, 0xf2, 0x37, 0xfe, 0x5d, 0xa9, 0xec, 0xbf, 0x95, 0xca, 0x48,
	0xf3, 0xa2, 0x2c, 0x8d, 0xcd, 0x7b, 0xc3, 0x68, 0xdc, 0x63, 0x29, 0xe9, 0x89, 0x87, 0x7e, 0x1e,
	0x42, 0x53, 0xb9, 0x48, 0xc2, 0x46, 0x5f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x1c, 0x5b, 0x1d,
	0x87, 0xe9, 0x02, 0x00, 0x00,
}
